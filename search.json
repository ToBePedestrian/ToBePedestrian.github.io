[{"title":"二通插装阀","path":"/2024/08/20/二通插装阀/","content":"插装阀通常需要安装在液压集成块中才能正常工作，它的种类也包括压力控制阀、方向控制阀和流量控制阀三大类。插装阀通常都是锥阀，也可以是滑阀。锥型插装阀往往是二通阀，而滑阀式插装阀可以有二通、三通或四通的设计。二通插装阀是一种液压单向阀，故又称二通锥阀或称逻辑阀；插装阀的安装方式有两种，一种是滑入式，一种是螺旋式，二通插装阀是滑入式的，所以又叫滑入式插装阀。 1.特点 结构简单、紧凑、工艺性好，流动流阻小； 同流能力大，适用于大流量场合； 阀芯动作灵敏，响应快； 密封性能好，泄漏少； 工作可靠，抗污染能力强，寿命长； 适用于各种液压介质：如液压油、乳化液、水质； 便于实现集成化，能高度集成，适与数字元件、比例元件及计算机组合使用，实现自动控制； 易于实现通用化、标准化、系统化。 2.基本结构二通插装阀的主要结构包括插装件、控制盖板、先导控制阀和集成块四部分，如图所示： 插装件：由阀芯、阀套、弹簧、密封件组成, 可以是锥阀结构, 也可以是滑块结构。它的主要功能是控制主油路中油流方向, 压力和流量；等通常是直接将它插进阀块内，并通过顶部的盖板将其固定在阀块上，以实现密封。。 控制盖板：由盖板内嵌装各种微型先导控制元件 (如梭阀、插式调压阀等) 以及其它元件组成。主要功用是固定插装件, 内嵌的各种微型先导控制元件与先导控制阀结合可以控制插装阀的工作状态, 控制盖板可分为:方向控制盖板、压力控制盖板、流量控制盖板三大类。当具有两种以上功能时, 称为复合控制盖板。 先导控制阀：安装在控制盖板上 (可集成块上) , 对插装件动作进行控制的小通径控制阀。主要有6mm和10mm通径的电磁滑阀或球阀、比例阀、可调阻尼器、缓冲器以及液控先导阀等。 集成块体：用来安装插装件、控制盖板和其它控制阀、沟通主油路和控制路的块体。 3.工作原理 二通插装阀阀芯所受合力如上图所示，合力方程（不计阀芯自重和摩擦力)如下： ∑F=PxAx-PaA1-PbA2+F1+F2式中F1——弹簧力，F2——液动力由上式可知，当∑F＞0，阀芯关闭；当∑F＜0，阀芯开启；当∑F=0，阀芯处于平衡位置。 压降经验公式Q=d2/2*√ΔP式中 Q——通过的流量 L/min， d——小孔直径 mm ， ΔP——压降 bar 常见应用 直接控制，单向阀作用 控制油可以来自A口也可以来自B口，来自A口时；A到B不通，B到A自由流动，反之亦然。 先导控制 先导控制，可以通过先导阀改变液流的通断方向，控制油可以来自A口、B口或者其他控制油路，需要注意的是先导阀的T口需要单独引回油箱。 方向阀，三位四通阀控制回路 油缸伸出，相当于三位四通阀右位，如下图 油缸缩回，相当于三位四通阀左位，如下图： 调整先导阀，可实现差动补油回路，如下图： 上述回路每个插装阀都与独立的先导控制阀，可以整合使用一个先导阀完成，但需要注意以下几点： 如果插装阀开启有特定的顺序，则需要考虑使用单独的先导阀； 优化系统主要靠改变阀开启、关闭的时间； 油液的粘度变化会对系统的特性有一定影响。 另外，阀芯有带减震尾部和不带减震尾部两种，有如下特点： 带减震的阀开启和关闭时间可能会略长，相同先导流量下动作会相对迟缓，因为带减震尾部的阀全开的行程要长一些，但有减震作用； 阀完全开启的时间越长，则开启过程越平稳；阀口关闭时，越接近关闭，压差就越大，这会使关闭加快，易对阀座产生很强的冲击。 可以通过在以下油道设置节流，达到影响阀动作时间的目的： 在1处进行节流，影响进入弹簧腔的流量，从而影响阀的关闭时间； 在2处进行节流，影响流出弹簧腔的流量，从而影响阀的开启时间； 在3处进行节流，影响流进入/出弹簧腔的流量，从而影响阀的开启/关闭时间； 流量控制阀 上图通过二通插装阀实现节流调速，通过调节二通插装阀弹簧腔弹簧的压缩量，进而改变阀芯开启的压力，即控制腔的压力，从而控制主油路流量，使一部分油液流回油箱，进而控制执行元件的速度。 压力阀 溢流阀 直动式溢流阀：手动比例控制的先导阀（4） 被集成于控制盖板（2）中，或作为先导阀安裝在控制盖板（ 2）上 电磁卸荷溢流阀： 比例溢流阀： 减压阀 减压阀有两种形式，一种时常开型，一种是常闭型 常开型： 由一个面积比1:1的阀座（B口没有有效作用面积）和一个带溢流阀功能的控制盖板组成；当A口压力低于控制盖板上先导阀设定压力时，主阀上液压力处于平衡状态，弹簧力使主阀保持开启状态，油液可以自由的从B口流向A口；当A口压力达到导阀设定值后，导阀开启，主阀弹簧腔油液流动，产生压差，使主阀阀口关闭。 常闭型：由一个插装溢流阀（主阀）和一个带有减压阀的控制盖板作为先导阀组成；A口提供的控制油液通过进油节流孔和主阀弹簧腔的油液一起经过常开的先导减压阀流入B口，主阀上下产生压差，主阀开启，A到B自由流动；当B口压力达到先导减压阀的设定的压力时，先导阀趋向关闭，主阀弹簧腔油液停止流动，主阀上下无压差，主阀关闭。 带闭锁功能的常闭型：电磁铁不通电，插芯关闭，电磁铁通电，减压功能。（闭锁：油路断开） 常闭型比例可调减压阀：B压力由比例溢流阀调定 常闭型比例可调带闭锁减压阀： 常开型和常闭型比较： - 常开型油液流向由B到A，常闭式相反； - 常开型型阀上的作用力小，控制精度高，可作为压力补偿器； - 常闭式启动平稳，关闭快，有闭锁功能，可有节流功能。 顺序阀 通过控制盖板中先导阀来设定所需的顺序压力，先导控制油可以是由内部A口经控制油口x（或Z2口），再经过节流孔提供；也可以是外部从X口经节流孔提供；当控制油压力达到先导阀弹簧设定压力，先导阀开启，主阀弹簧腔油液流向油箱，产生压差，主阀开启A到B流通（存在一点疑问，弹簧腔怎么补充油液）。 系统中的应用 液压缸需完成以下四个动作： 快速进给 压下 压下释放 回退 系统分解： 动力源系统 主要两个作用： 系统主压力控制（得电主溢流功能） 低压卸荷功能（失电卸荷） 油缸回退 Y5吸合，系统压力上升，油液通过阀2进入油缸有杆腔，油缸缩回。 油缸泄压 油缸缩回前，必须给无杆腔泄压；因为油缸处于压紧状态，无杆腔压力很高，直接回到油箱，会有很大的冲击，因此使用带减震尾部的插装阀，并且在导阀T口增加阻尼背压，当Y2吸合时，油缸无杆腔完成泄压。 油缸快速伸出 Y3需要得电，Y3不得电，阀4处于完全关闭状态，油缸无法伸出，阻尼孔4.5的作用是防止4号阀关闭时产生冲击；但是在油缸缩回时必须保证4号阀关闭，4.1号阀的作用是保证4号阀的单向阀功能，只能A到B，不允许B到A Y1必须失电，Y1失电，2号阀处于关闭状态，才能确保油缸伸出： 油缸有杆腔需要回油，所以Y4需要得电，阀5开启，油缸有杆腔油液流回油箱，因为5号阀在油缸下降时需要有缓冲作用，所以需要带减震尾部的插装阀： 平衡阀功能 当Y4失电时，油缸下降速度变慢，因为油液需经阀6流回油箱，阀6的控制腔连接阀6.2，阀6.2弹簧设定的压力决定了阀6的开度，进而决定油缸下降速度；阀6.3为二次溢流阀，设定值高于6.2，节流孔6.1影响阀6的开启时间 互锁保护 5、6号阀的动作必须与4号阀有互锁功能，防止5、6号阀早开或过快关闭，因此6.2、6.3的回油接在4.1阀上；7号溢流阀有消除压力冲击的作用，8号阀确保泵泄荷时，5、6号阀也能完成紧急关闭。","tags":["液压","二通阀，插装阀","二通插装阀"],"categories":["液压","阀"]},{"title":"液压单稳阀","path":"/2024/08/20/液压单稳阀/","content":"单稳阀是单支路稳定分流阀的简称，是流量阀的一种。它为液压系统提供并保证单支路输出流量的稳定，而不随液压泵输出流量的变化而变化。 1.单稳阀的分类 按供油泵数量 单泵单只路稳定分流阀 一个泵供给两个系统，主要用于小功率液压系统 双泵单支路稳定分流阀 两个泵供给两个系统，主要用于大功率液压系统 上述两个系统均是为了获得稳定的流量，以保证转向系统的稳定性和安全性 按分流形式 恒流型 分流型 按结构形式分 与转向阀分体型 与转向阀整体型 2.单稳阀的工作原理 如图1所示,单稳阀主要由阀体、阀芯、弹簧、阻尼塞、安全阀等组成。当泵以一定量供油时，从P口流入的油液QS:一路经定节流孔c和变节流口a输出,供给液压转向系统使用，此油路为稳定油路A,流量QA;另一路通过变节流口b流向其他油路或者回油箱,此油路为分流油路B,流量QB。阀芯主要受节流口a、节流口b处的液动力，节流孔c前后的压差，以及弹簧的作用力平衡。 如果油泵供油量和转向系统负载恒定，则阀芯处于阀体内某一平衡位置,流过定节流口c和变节流口a的流量QA保持恒定。 (1)若转向油路A负载不变,而油泵供油量同步变化时。当P口进油流量小于阀设定的稳流流量时，定节流孔c前后压差较小，不足以推动阀芯移动,变节流口b不打开,开度为0,全部油液QS:经过定节流孔c和变节流口a,从油路A进入转向系统;当P口进油流量大于阀设定的额定流量时，通过定节流孔c的流量增加，则定节流孔c前后压差也相应增大，推动阀芯向右移动，弹簧压缩，使变节流口 a开度减小,变节流口b开度增大,将多余流量从B油路输出。(2)若油泵供油量不变,而转向油路A压力突然增加时,阀芯瞬间要向左移动,增大变节流口a的开度,减小变节流口b的开度。但由于阀芯主要靠定节流孔c前后压差维持平衡,在流量不变,定节流孔c前后压差不变的情况下,阀芯最终将恢复平衡,保持流量不变。 对于一个单稳阀，设定定差溢流阀的回位弹簧力为F，其阀芯两端面积都为V，那么节流口2两端的压差便会通过B口的开启面积取得一个平衡，即 P1=P2+P弹 (通过节流口2有液体流动时，P1始终高于P2)，也就是说，节流口2两端的压差几乎为常数(不考虑液动力的影响，为消除液动力，在阀体的设计上已进行了补偿)，节流口过流面积一定，压差一定，那么通过的流量就基本恒定。 通过调整弹簧力或节流口面积，都可以改变稳定流量的数值。节流口1起到滤波的作用，稳定定差溢流阀控制腔的压力，使其不随系统压力波动产生较大的波动因为这段管路几乎不存在液体的流动，所以不存在压力损失，控制腔的压力等于P1。 注意： 只有当流量超过设定的稳流流量时，阀才起到稳流作用； 泵流量超过单稳阀设定流量时，稳流油路的供油量会有略微上升，并非完全保持不变，但增幅不大，对转向系统稳定性影响较小； 当稳定油路负载发生变化时，阀稳定油路的流量依然能维持基本恒定，表明这种阀的稳流特性良好。","tags":["液压","单稳阀","分流阀","单支路稳定分流阀"],"categories":["液压","阀"]},{"title":"流量优先阀","path":"/2024/07/14/液压流量优先阀/","content":"液压流量优先阀 流量优先阀属于逻辑阀的一种，其作用是将油液优先分配给特定的油路（CF），且流量恒定，并将多余的油液分配给其他油路（EF），以达到稳定分配流量目的。原则上，就像一个三通流量控制阀，总是为执行元件提供所需流量的优先级，并将剩余流量传递给其他执行元件。在供应不足的情况下，对无优先级的执行原件不再供应。 原理图 上图为静态流量优先阀和动态流量优先阀的液压原理符号。&lt;/br&gt;&lt;/br&gt; 结构图 如图1.3所示,优先阀主要由 4个基本元件组成:阀芯、阻尼孔、弹簧、阀体。 案例原理分析 下图为液压转向系统，这个单独可能不太好理解，还是需要通过具体液压回路进行理解： 如图所示，其 CF口接转向器进油口,EF口接工作油路,LS 口与转向器 LS 反馈油口连接。 当泵未工作时,液压优先阀阀芯在弹簧力的作用下处于左端,此时CF口打开EF口关闭; 当泵启动后,进口流量优先从 P-CF 口流向转向器经转向器中位节流口流回油箱。转向器中位节流口两端的压力分别经过优先阀两端的阻尼孔传到阀芯两端的阀腔内。 当进口流量小于转向所需流量时,转向器中位节流口两端压差较小(孔口流量公式Q=CdA(ΔP/ρ)1/2，开口面积A不变的情况下，流量Q越小，压差ΔP越小),优先阀阀芯两端面压差小于弹簧预紧力,阀芯没有位移。 当进口流量大于转向所需流量时,转向器中位节流口两端压差较大, 优先阀阀芯两端面压差大于弹簧预紧力,阀芯向右移动，P-EF口开大，P-CF口关小,直到优先阀阀芯两端面压差和弹簧力相等，阀芯处于平衡位置,多余的进口流量从EF口流出。 当负载不变,转向速度减小时,转向器进油口关小,优先阀左腔压力等于 CF 口压力,并随之升高右腔压力等于转向负载压力,并保持不变,阀芯两端压差增大(Q不变，开口面积减小[产生压降 PEF&gt;转向器出油口压力]，压差增大),向右移动,P-CF 阀口面积减小（换向阀开口面积A不变的情况下，流量Q减小，压差ΔP减小),CF 口压力随之减小。因此,液压优先阀动过动态调节维持转向器前后压差为一个定值,不受转向速度的影响。 当转向速度不变,转向负载压力减小时,液压优先阀右腔压力降低,阀芯向右移动,P-CF 口关小,CF 口压力随之降低，从而使转向器前后压差不受转向负载变化的影响。 当工作负载压力减小时,P口和 CF口压力随之减小,液压优先阀左腔压力降低，阀芯向左移动P-CF口开大,CF口压力随之升高,因此,转向器前后压差同样不受工作负载变化的影响。","tags":["液压","流量分配","逻辑阀"],"categories":["液压","阀"]},{"title":"液压常用公式汇总","path":"/2024/06/24/液压常用公式汇总/","content":"液压公式汇总 来源：《机械设计手册》成大先 文章学习整理：ToBe (穿越时空的猫) 风起于青萍之末，浪成于微澜之间。跌谷底也要开花，沉海底也要望月。 1.流体力学流体主要物理性质公式 风吹枝头影飘落，人随风去情自留。呓言寐语随风吟，风止山野意难平。 流体静力学 怀疑一切与相信一切一样简单（都是放弃思考） 流体动力学 何须叹别余晖尽，人间华灯才初上 雷诺数、流态、压力损失 局部阻力系数和沿程阻力系数圆管沿程阻力系数 新管内壁绝对粗糙度 管道入口局部阻力系数 管道出口局部阻力系数 管道扩大处局部阻力系数 管道缩小处局部阻力系数 弯管局部阻力系数 分支管局部阻力系数 交贯钻孔通道局部阻力系数 阀口局部阻力系数 小孔流量公式 平行平板间缝隙流公式 环形缝隙流公式 液压冲击公式 迅速关闭或打开液流通道时产生的液压冲击计算公式 急剧改变液压缸运动速度时由于液体及运动部件的惯性作用引起的压力冲击公式 2.液压缸 午夜短促，苍穹悠远 允许行程S和计算长度L 缸筒计算 缸径推荐尺寸： 缸筒推荐壁厚： 活塞杆计算 导向套计算 缓冲装置计算 3.液压泵和液压马达 风紧雁行高，无边落木萧萧。楚天魂梦与香消，青山暮暮朝朝 功率扭矩计算公式 4.液压辅件 遇而不改，是谓过矣 管路计算 蓄能器蓄能用蓄能器计算 其他用途蓄能器计算 重锤式蓄能器计算 非隔离式蓄能器计算 冷却器计算 过滤器 油箱 油箱中油液冷却与加热","tags":["液压","公式","设计计算"],"categories":["液压","公式"]},{"title":"阀前补偿与阀后补偿","path":"/2024/06/23/阀前补偿与阀后补偿/","content":"阀前补偿与阀后补偿不论是阀前补偿还是阀后补偿,一般都是在负载敏感液压系统中提到；在液压系统中，速度取决于流量，调节节流口的大小从而调节流量，但是如果节流口前后压差变化较大，此时节流口就很难精确的进行流量控制；而压力补偿阀就是用来控制节流口前后的压力差，补偿的就是压差，以保证节流口前后压差保持在某一定值。 阀前补偿 阀前补偿是将压力补偿器布置在液压泵与主阀之间，工作时压力油先经过补偿器再通过主阀上节流口，节流口进口压力为：P进=P1+F弹/A，节流口出口压力为：P出=P1，所以前后压差为ΔP=P进-P出=F弹/A=Constant。 阀前补偿是阀前减压，利用定差减压阀的阀后压力，使各联主阀前后压差一定,只要每联弹簧设定压力相同，则△P1=△P2=…=△Pi;各联负载的流量只与主阀开口面积有关，而不受负载影响，提高了阀的控制性能。 阀前补偿回路通过梭阀将每一联的出口压力进行比较，将最大的那一联压力Pmax再反馈给负载敏感泵上的负载敏感阀，然后和负载敏感阀的弹簧设定压力Px一起与泵出口压力Pp进行比较，进而调节泵的排量。所以泵出口压力Pp=Pmax+Px。 特点 当有两个或以上执行元件时，如果主泵提供的流量满足系统所需，则各执行元件按设定速度运行；当主泵提供的流量无法满足系统所需，主泵流量首先给负载小的执行元件提供流量，负载小的执行元件完全满足后才向其他执行元件供油。 阀后补偿 阀后补偿系统是指压力补偿阀布置在主阀与执行元件之间，工作时压力油先通过主阀上节流口，再通过补偿器;第i联的节流口出口压力为Pi,最大负载压力为Pmax，补偿阀弹簧设定压力为P弹，泵出口压力为Pp，则有：Pi=Pmax+P弹，如果每联补偿阀弹簧设定力大小相同，则，P1=P2=P3=…；所以节流口前后压差ΔP=Pp-Pi,所以有：ΔP1=ΔP2=ΔP3=…。所有节流口前后压差相同，根据节流口流量公式：Q=CdA(2ΔP/ρ)½ ,因此流经各节流口的流量与各节流口的开口面积成正比,即Q1/Q2=A1/A2。 负载敏感泵出口压力为：Pp=Pmax+Px（负载敏感阀设定压力），所以多路阀前后压差为Px。 二者特点 阀前补偿和阀后补偿都是为了使负载运动速度与负载压力无关； 阀前补偿和阀后补偿补偿器都会能量损耗。 如果主泵提供的流量无法满足系统所需流量，阀前补偿的情况是：主泵流量优先往负荷小的负载提供流量，当负荷小的负载运动停止后，才往其他的负载提供流量；阀后补偿的情况是：同比减少各个负载的流量供给，使各负载根据主阀开口同比降低速度。 阀前补偿补偿器设定的各联压差为常值，可以更好的控制负载速度，调速刚性较好；阀后补偿补偿器设定的各联压差相等，并不是常值，调速刚性不是很好，需要泵的压差补偿器共同提高调速刚性。 当阀后补偿的补偿器设置在回油路上，可应用于负负载的工况，可以更准确控制负载速度，防止吸空和气蚀。","tags":["液压","阀前补偿","阀后补偿"],"categories":["液压"]},{"title":"Hello World","path":"/2023/05/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/about/index.html","content":"何时杖尔看南雪，我与梅花两白头。文章项目GitHub 关于我 我们就像落在电线上的麻雀，只为暂歇羽翼，而彼此相邻"},{"path":"/friends/index.html","content":"友情链接 Java开发朋友们Rewind我们一日日度过的所谓的日常，实际上可能是连接不断的奇迹H游龙当归海，海不迎我自来也，云鹤当归天，天不迎我妙木仙 网站主题来源xaoxuu如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。"},{"title":"这是分页标题","path":"/wiki/stellar/index.html","content":"JDK源码数组ArrayList1.类图ArrayList 实现的接口、继承的抽象类，如下图所示： 实现了 4 个接口，分别是： java.util.List 接口，提供数组的添加、删除、修改、迭代遍历等操作。 java.util.RandomAccess 接口，表示 ArrayList 支持快速的随机访问。 java.io.Serializable 接口，表示 ArrayList 支持序列化的功能。 java.lang.Cloneable 接口，表示 ArrayList 支持克隆。 继承了java.util.AbstractList 抽象类，而 AbstractList 提供了 List 接口的骨架实现，大幅度的减少了实现迭代遍历相关操作的代码 2.属性ArrayList 的属性很少，仅仅 2 个。如下图所示： elementData 属性：元素数组。其中，图中红色空格代表我们已经添加元素，白色空格代表我们并未使用。 size 属性：数组大小。注意，size 代表的是 ArrayList 已使用 elementData 的元素的数量，对于开发者看到的 #size() 也是该大小。并且，当我们添加新的元素时，恰好其就是元素添加到 elementData 的位置（下标）。当然，我们知道 ArrayList 真正的大小是 elementData 的大小。 对应代码如下： 12345678910111213141516171819202122// ArrayList.java/** * 元素数组。 * * 当添加新的元素时，如果该数组不够，会创建新数组，并将原数组的元素拷贝到新数组。之后，将该变量指向新数组。 * * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 不使用 private 修饰，方便内嵌类的访问。/** * 已使用的数组大小 * * The size of the ArrayList (the number of elements it contains). * * @serial */private int size; 3.构造方法ArrayList 一共有三个构造方法： ① #ArrayList(int initialCapacity) #ArrayList(int initialCapacity) 构造方法，根据传入的初始化容量，创建 ArrayList 数组。如果我们在使用时，如果预先指到数组大小，一定要使用该构造方法，可以避免数组扩容提升性能，同时也是合理使用内存。代码如下： 12345678910111213141516171819202122232425// ArrayList.java/** * 共享的空数组对象。 * * 在 &#123;@link #ArrayList(int)&#125; 或 &#123;@link #ArrayList(Collection)&#125; 构造方法中， * 如果传入的初始化大小或者集合大小为 0 时，将 &#123;@link #elementData&#125; 指向它。 * * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList(int initialCapacity) &#123; // 初始化容量大于 0 时，创建 Object 数组 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; // 初始化容量等于 0 时，使用 EMPTY_ELEMENTDATA 对象 &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; // 初始化容量小于 0 时，抛出 IllegalArgumentException 异常 &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125; 如果初始化容量为 0 时，使用 EMPTY_ELEMENTDATA 空数组。在添加元素的时候，会进行扩容创建需要的数组。 ② #ArrayList(Collection&lt;? extends E&gt; c) #ArrayList(Collection&lt;? extends E&gt; c) 构造方法，使用传入的 c 集合，作为 ArrayList 的 elementData 。代码如下： 123456789101112131415161718// ArrayList.javapublic ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将 c 转换成 Object 数组 elementData = c.toArray(); // 如果数组大小大于 0 if ((size = elementData.length) != 0) &#123; // defend against c.toArray (incorrectly) not returning Object[] // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652) // &lt;X&gt; 如果集合元素不是 Object[] 类型，则会创建新的 Object[] 数组，并将 elementData 赋值到其中，最后赋值给 elementData 。 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); // 如果数组大小等于 0 ，则使用 EMPTY_ELEMENTDATA 。 &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 在 &lt;X&gt; 处的代码。它是用于解决 JDK-6260652 的 Bug 。它在 JDK9 中被解决，也就是说，JDK8 还会存在该问题。 看一段能够触发 JDK-6260652 的测试代码，然后分别在 JDK8 和 JDK13 下执行。代码如下： 12345678910// ArrayListTest.javapublic static void test02() &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); Object[] array = list.toArray(); // JDK8 返回 Integer[] 数组，JDK9+ 返回 Object[] 数组。 System.out.println(&quot;array className ：&quot; + array.getClass().getSimpleName()); // 此处，在 JDK8 和 JDK9+ 表现不同，前者会报 ArrayStoreException 异常，后者不会。 array[0] = new Object();&#125; JDK8 执行如下图所示： JDK13 执行如下图所示： 在 JDK8 中，返回的实际是 Integer [] 数组，那么我们将 Object 对象设置到其中，肯定是会报错的。 ③ #ArrayList() 无参数构造方法 #ArrayList() 构造方法，也是我们使用最多的构造方法。代码如下： 1234567891011121314151617181920212223242526// ArrayList.java/** * 默认初始化容量 * * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * 共享的空数组对象，用于 &#123;@link #ArrayList()&#125; 构造方法。 * * 通过使用该静态变量，和 &#123;@link #EMPTY_ELEMENTDATA&#125; 区分开来，在第一次添加元素时。 * * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 在学习 ArrayList 的时候，认为在未设置初始化容量时，ArrayList 默认大小为 10 。但是此处，可以看到初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个空数组。这是为什么呢？ArrayList 考虑到节省内存，一些使用场景下仅仅是创建了 ArrayList 对象，实际并未使用。所以，==ArrayList 优化成初始化是个空数组，在首次添加元素时，才真正初始化为容量为 10 的数组==。 那么为什么单独声明了 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 空数组，而不直接使用 EMPTY_ELEMENTDATA 呢？DEFAULTCAPACITY_EMPTY_ELEMENTDATA首次扩容为 10 ，而EMPTY_ELEMENTDATA` 按照 1.5 倍扩容从 0 开始而不是 10 。 4.添加单个元素① 顺序添加单个元素 #add(E e) 方法，顺序添加单个元素到数组。代码如下： 123456789101112131415161718192021// ArrayList.java@Overridepublic boolean add(E e) &#123; // &lt;1&gt; 增加数组修改次数 modCount++; // 添加元素 add(e, elementData, size); // 返回添加成功 return true;&#125;private void add(E e, Object[] elementData, int s) &#123; // &lt;2&gt; 如果容量不够，进行扩容 if (s == elementData.length) elementData = grow(); // &lt;3&gt; 设置到末尾 elementData[s] = e; // &lt;4&gt; 数量大小加一 size = s + 1;&#125; &lt;1&gt; 处，增加数组修改次数 modCount 。在父类 AbstractList 上，定义了 modCount 属性，用于记录数组修改次数。 &lt;2&gt; 处，如果元素添加的位置就超过末尾（数组下标是从 0 开始，而数组大小比最大下标大 1），说明数组容量不够，需要进行扩容，那么就需要调用 #grow() 方法，进行扩容。 &lt;3&gt; 处，设置到末尾。 &lt;4&gt; 处，数量大小加一。 ② 插入单个元素到指定位置 再看看 #add(int index, E element) 方法，插入单个元素到指定位置。代码如下： 1234567891011121314151617181920212223242526// ArrayList.javapublic void add(int index, E element) &#123; // 校验位置是否在数组范围内 rangeCheckForAdd(index); // 增加数组修改次数 modCount++; // 如果数组大小不够，进行扩容 final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) elementData = grow(); // 将 index + 1 位置开始的元素，进行往后挪 System.arraycopy(elementData, index, elementData, index + 1, s - index); // 设置到指定位置 elementData[index] = element; // 数组大小加一 size = s + 1;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 6.数组扩容#grow() 方法，扩容数组，并返回它。整个的扩容过程，首先创建一个新的更大的数组，一般是 1.5 倍大小（为什么说是一般呢，稍后会看到，会有一些小细节），然后将原数组复制到新数组中，最后返回新数组。代码如下： 1234567891011121314151617181920// ArrayList.javaprivate Object[] grow() &#123; // &lt;1&gt; return grow(size + 1);&#125;private Object[] grow(int minCapacity) &#123; int oldCapacity = elementData.length; // &lt;2&gt; 如果原容量大于 0 ，或者数组不是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，计算新的数组大小，并创建扩容 if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity &gt;&gt; 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); // &lt;3&gt; 如果是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 数组，直接创建新的数组即可。 &#125; else &#123; return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; &#125;&#125; &lt;1&gt; 处，调用 #grow(int minCapacity) 方法，要求扩容后至少比原有大 1 。因为是最小扩容的要求，实际是允许比它大。 &lt;2&gt;处，如果原容量大于 0 时，又或者数组不是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，则计算新的数组大小，并创建扩容。 ArraysSupport#newLength(int oldLength, int minGrowth, int prefGrowth) 方法，计算新的数组大小。简单来说，结果就是 Math.max(minGrowth, prefGrowth) + oldLength ，按照 minGrowth 和 prefGrowth 取大的。 一般情况下，从 oldCapacity &gt;&gt; 1 可以看处，是 1.5 倍扩容。但是会有两个特殊情况： 1）初始化数组要求大小为 0 的时候，0 &gt;&gt; 1 时（&gt;&gt; 1 为右移操作，相当于除以 2）还是 0 ，此时使用 minCapacity 传入的 1 。 2）在下文中，会看到添加多个元素，此时传入的 minCapacity 不再仅仅加 1 ，而是扩容到 elementData 数组恰好可以添加下多个元素，而该数量可能会超过当前 ArrayList 0.5 倍的容量。 &lt;3&gt; 处，如果是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 数组，直接创建新的数组即可。思考下，如果无参构造方法使用 EMPTY_ELEMENTDATA 的话，无法实现该效果了。 既然有数组扩容方法，那么是否有缩容方法呢？在 #trimToSize() 方法中，会创建大小恰好够用的新数组，并将原数组复制到其中。代码如下： 123456789101112// ArrayList.javapublic void trimToSize() &#123; // 增加修改次数 modCount++; // 如果有多余的空间，则进行缩容 if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA // 大小为 0 时，直接使用 EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); // 大小大于 0 ，则创建大小为 size 的新数组，将原数组复制到其中。 &#125;&#125; 同时，提供 #ensureCapacity(int minCapacity) 方法，保证 elementData 数组容量至少有 minCapacity 。代码如下： 12345678910111213// ArrayList.javapublic void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; elementData.length // 如果 minCapacity 大于数组的容量 &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) &#123; // 如果 elementData 是 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的时候， // 需要最低 minCapacity 容量大于 DEFAULT_CAPACITY ，因为实际上容量是 DEFAULT_CAPACITY 。 // 数组修改次数加一 modCount++; // 扩容 grow(minCapacity); &#125;&#125; 可以将这个方法理解成主动扩容。 7.添加多个元素#addAll(Collection&lt;? extends E&gt; c) 方法，批量添加多个元素。在我们明确知道会添加多个元素时，推荐使用该该方法而不是添加单个元素，避免可能多次扩容。代码如下： 12345678910111213141516171819202122// ArrayList.javapublic boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 转成 a 数组 Object[] a = c.toArray(); // 增加修改次数 modCount++; // 如果 a 数组大小为 0 ，返回 ArrayList 数组无变化 int numNew = a.length; if (numNew == 0) return false; // &lt;1&gt; 如果 elementData 剩余的空间不够，则进行扩容。要求扩容的大小，至于能够装下 a 数组。 Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); // &lt;2&gt; 将 a 复制到 elementData 从 s 开始位置 System.arraycopy(a, 0, elementData, s, numNew); // 数组大小加 numNew size = s + numNew; return true;&#125; &lt;1&gt; 处，如果 elementData 剩余的空间不足，则进行扩容。要求扩容的大小，至于能够装下 a 数组。当然，在 ==6. 数组扩容== 的小节，我们已经看到，如果要求扩容的空间太小，则扩容 1.5 倍。 &lt;2&gt; 处，将 a 复制到 elementData 从 s 开始位置。 再来看看 #addAll(int index, Collection&lt;? extends E&gt; c) 方法，从指定位置开始插入多个元素。代码如下： 123456789101112131415161718192021222324252627282930313233// ArrayList.javapublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 校验位置是否在数组范围内 rangeCheckForAdd(index); // 转成 a 数组 Object[] a = c.toArray(); // 增加数组修改次数 modCount++; // 如果 a 数组大小为 0 ，返回 ArrayList 数组无变化 int numNew = a.length; if (numNew == 0) return false; // 如果 elementData 剩余的空间不够，则进行扩容。要求扩容的大小，至于能够装下 a 数组。 Object[] elementData; final int s; if (numNew &gt; (elementData = this.elementData).length - (s = size)) elementData = grow(s + numNew); // 【差异点】如果 index 开始的位置已经被占用，将它们后移 int numMoved = s - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将 a 复制到 elementData 从 s 开始位置 System.arraycopy(a, 0, elementData, index, numNew); // 数组大小加 numNew size = s + numNew; return true;&#125; 判断添加元素的位置，如果当前数组大小减去需要添加的位置下标大于零，说明该位置有元素，那么久进行移动，移动添加元素的个数位，然后将新添加的元素指定位置开始从复制到数组中。 8.移除单个元素#remove(int index) 方法，移除指定位置的元素，并返回该位置的原元素。代码如下： 123456789101112131415// ArrayList.javapublic E remove(int index) &#123; // 校验 index 不要超过 size Objects.checkIndex(index, size); final Object[] es = elementData; // 记录该位置的原值 @SuppressWarnings(&quot;unchecked&quot;) E oldValue = (E) es[index]; // &lt;X&gt;快速移除 fastRemove(es, index); // 返回该位置的原值 return oldValue;&#125; 重点是 &lt;X&gt; 处，调用 #fastRemove(Object[] es, int i) 方法，快速移除。代码如下 123456789101112// ArrayList.javaprivate void fastRemove(Object[] es, int i) &#123; // 增加数组修改次数 modCount++; // &lt;Y&gt;如果 i 不是移除最末尾的元素，则将 i + 1 位置的数组往前挪 final int newSize; if ((newSize = size - 1) &gt; i) // -1 的原因是，size 是从 1 开始，而数组下标是从 0 开始。 System.arraycopy(es, i + 1, es, i, newSize - i); // 将新的末尾置为 null ，帮助 GC es[size = newSize] = null;&#125; #remove(Object o) 方法，移除首个为 o 的元素，并返回是否移除到。代码如下： 12345678910111213141516171819202122232425// ArrayList.javapublic boolean remove(Object o) &#123; final Object[] es = elementData; final int size = this.size; // &lt;Z&gt; 寻找首个为 o 的位置 int i = 0; found: &#123; if (o == null) &#123; // o 为 null 的情况 for (; i &lt; size; i++) if (es[i] == null) break found; &#125; else &#123; // o 非 null 的情况 for (; i &lt; size; i++) if (o.equals(es[i])) break found; &#125; // 如果没找到，返回 false return false; &#125; // 快速移除 fastRemove(es, i); // 找到了，返回 true return true;&#125; 和 #remove(int index) 差不多，就是在 &lt;Z&gt; 处，改成获得首个为 o 的位置，之后就调用 #fastRemove(Object[] es, int i) 方法，快速移除即可。 9. 移除多个元素先看 #removeRange(int fromIndex, int toIndex) 方法，批量移除 [fromIndex, toIndex) 的多个元素，注意不包括 toIndex 的元素噢。代码如下： 1234567891011121314151617// ArrayList.javaprotected void removeRange(int fromIndex, int toIndex) &#123; // 范围不正确，抛出 IndexOutOfBoundsException 异常 if (fromIndex &gt; toIndex) &#123; throw new IndexOutOfBoundsException( outOfBoundsMsg(fromIndex, toIndex)); &#125; // 增加数组修改次数 modCount++; // &lt;X&gt; 移除 [fromIndex, toIndex) 的多个元素 shiftTailOverGap(elementData, fromIndex, toIndex);&#125;private static String outOfBoundsMsg(int fromIndex, int toIndex) &#123; return &quot;From Index: &quot; + fromIndex + &quot; &gt; To Index: &quot; + toIndex;&#125; &lt;X&gt; 处，调用 #shiftTailOverGap(Object[] es, int lo, int hi) 方法，移除 [fromIndex, toIndex) 的多个元素。代码如下： 123456789// ArrayList.javaprivate void shiftTailOverGap(Object[] es, int lo, int hi) &#123; // 将 es 从 hi 位置开始的元素，移到 lo 位置开始。 System.arraycopy(es, hi, es, lo, size - hi); // 将从 [size - hi + lo, size) 的元素置空，因为已经被挪到前面了。 for (int to = size, i = (size -= hi - lo); i &lt; to; i++) es[i] = null;&#125; 和 #fastRemove(Object[] es, int i) 方法一样的套路，先挪后置 null 。 有一点要注意，ArrayList 特别喜欢把多行代码写成一行。所以，可能疑惑，貌似这里没有修改数组的大小 size 啊？答案在 i = (size -= hi - lo) ，简直到精简到难懂。 #removeAll(Collection&lt;?&gt; c) 方法，批量移除指定的多个元素。简单来说，通过两个变量 w（写入位置）和 r（读取位置），按照 r 顺序遍历数组(elementData)，如果不存在于指定的多个元素中，则写入到 elementData 的 w 位置，然后 w 位置 + 1 ，跳到下一个写入位置。通过这样的方式，实现将不存在 elementData 覆盖写到 w 位置。代码如下： 12345// ArrayList.javapublic boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false, 0, size);&#125; 调用 #batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) 方法，批量移除指定的多个元素。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// ArrayList.javaboolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123; // 校验 c 非 null 。 Objects.requireNonNull(c); final Object[] es = elementData; int r; // Optimize for initial run of survivors // &lt;1&gt; 优化，顺序遍历 elementData 数组，找到第一个不符合 complement ，然后结束遍历。 for (r = from;; r++) &#123; // &lt;1.1&gt; 遍历到尾，都没不符合条件的，直接返回 false 。 if (r == end) return false; // &lt;1.2&gt; 如果包含结果不符合 complement 时，结束 if (c.contains(es[r]) != complement) break; &#125; // &lt;2&gt; 设置开始写入 w 为 r ，注意不是 r++ 。 // r++ 后，用于读取下一个位置的元素。因为通过上的优化循环，我们已经 es[r] 是不符合条件的。 int w = r++; try &#123; // &lt;3&gt; 继续遍历 elementData 数组，如何符合条件，则进行移除 for (Object e; r &lt; end; r++) if (c.contains(e = es[r]) == complement) // 判断符合条件 es[w++] = e; // 移除的方式，通过将当前值 e 写入到 w 位置，然后 w 跳到下一个位置。 &#125; catch (Throwable ex) &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // &lt;4&gt; 如果 contains 方法发生异常，则将 es 从 r 位置的数据写入到 es 从 w 开始的位置 System.arraycopy(es, r, es, w, end - r); w += end - r; // 继续抛出异常 throw ex; &#125; finally &#123; // &lt;5&gt; // 增加数组修改次数 modCount += end - w; // 将数组 [w, end) 位置赋值为 null 。 shiftTailOverGap(es, w, end); &#125; return true;&#125; complement参数，翻译过来是“补足”的意思。怎么理解呢？表示如果elementData元素在c集合中时，是否保留。 如果 complement 为 false 时，表示在集合中，就不保留，这显然符合 #removeAll(Collection&lt;?&gt; c) 方法要移除的意图。 如果 complement 为 true 时，表示在集合中，就暴露，这符合我们后面会看到的 #retainAll(Collection&lt;?&gt; c) 方法要求交集的意图。 &lt;1&gt;处，首先要知道这是一个基于 Optimize 优化的目的。我们是希望先判断是否elementData没有任何一个符合c的，这样就无需进行执行对应的移除逻辑。但是，又希望能够避免重复遍历，于是就有了这样一块的逻辑。总的来说，这块逻辑的目的是，优化，顺序遍历elementData数组，找到第一个不符合complement，然后结束遍历。 &lt;1.1&gt; 处，遍历到尾，都没不符合条件的，直接返回 false 。也就是说，丫根就不需要进行移除的逻辑。 &lt;1.2&gt; 处，如果包含结果不符合 complement 时，结束循环。可能有点难理解，我们来举个例子。假设 elementData 是 [1, 2, 3, 1] 时，c 是 [2] 时，那么在遍历第 0 个元素 1 时，则 c.contains(es[r]) != complement =&gt; false != false 不符合，所以继续缓存；然后，在遍历第 1 个元素 2 时，c.contains(es[r]) != complement =&gt; true != false 符合，所以结束循环。此时，我们便找到了第一个需要移除的元素的位置。当然，移除不是在这里执行 &lt;2&gt; 处，设置开始写入 w 为 r ，注意不是 r++ 。这样，我们后续在循环 elementData 数组，就会从 w 开始写入。并且此时，r 也跳到了下一个位置，这样间接我们可以发现，w 位置的元素已经被“跳过”了。 &lt;3&gt; 处，继续遍历 elementData 数组，符合条件，则进行移除。可能有点难理解，继续上述例子。遍历第 2 个元素 3 时候，c.contains(es[r]) == complement =&gt; false == false 符合，所以将 3 写入到 w 位置，同时 w 指向下一个位置；遍历第三个元素 1 时候，c.contains(es[r]) == complement =&gt; true == false 不符合，所以不进行任何操作。 &lt;4&gt; 处，如果 contains 方法发生异常，则将 es 从 r 位置的数据写入到 es 从 w 开始的位置。这样，保证我们剩余未遍历到的元素，能够挪到从从 w 开始的位置，避免多出来一些元素。 &lt;5&gt; 处，是不是很熟悉，将数组 [w, end) 位置赋值为 null 。 精妙之处就在于&lt;3&gt;处，前面拿到第一个符合移除的元素的下标r，将该下标赋值给w，然后再次从r处进行遍历，如果r+1处的元素不是需要移除的，那么就把r+1处的元素赋值给w处（即原来需要移除的元素位置），然后w+1；如此循环，遇到不是需要移除的就向前移动一位，是需要移除的就把当前需要移除的元素以后的元素向前移动一位，只有事不需要移除的元素时，w才会进行++操作,其实w就是记录写入点的。 #retainAll(Collection&lt;?&gt; c) 方法，求 elementData 数组和指定多个元素的交集。简单来说，恰好和 #removeAll(Collection&lt;?&gt; c) 相反，移除不在 c 中的元素。代码如下： 12345// ArrayList.javapublic boolean retainAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, true, 0, size);&#125; 举例：c是[1,2] elementData为[3,1,4,2]则该方法： 找出第一个不在c中的元素即3的下标0，然后w=0，r=1； 从r=1处遍历，发现elementData中的第二个元素也就是1存在于c中，那么就把1赋值给下标为w=0的位置，此时elementDate为[1,1,4,2];w=0+1 然后r=2,elementData中元素为4，不在c中，那么不进行赋值，w也不变，还是1； 再次遍历，r=3,elementData中元素为2，在c中，那么把元素2赋值到w=1位置，此时elementData为[1,2,4,2];w为2; 然后从下标为w=2处开始到size=4的元素赋值为null;此时elementData为[1,2]。 10.查找单个元素 查找首个为指定元素的位置 #indexOf(Object o) 方法，查找首个为指定元素的位置，正叙循环筛选。代码如下： 1234567891011121314151617181920212223242526// ArrayList.javapublic int indexOf(Object o) &#123; return indexOfRange(o, 0, size);&#125;int indexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; // o 为 null 的情况 if (o == null) &#123; for (int i = start; i &lt; end; i++) &#123; if (es[i] == null) &#123; return i; &#125; &#125; // o 非 null 的情况 &#125; else &#123; for (int i = start; i &lt; end; i++) &#123; if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; // 找不到，返回 -1 return -1;&#125; #contains(Object o) 方法 #contains(Object o) 方法，就是基于该方法实现。代码如下： 12345// ArrayList.javapublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 查找最后一个为指定元素的位置 有时我们需要查找最后一个为指定元素的位置，所以会使用到 #lastIndexOf(Object o) 方法,倒叙循环筛选。代码如下： 123456789101112131415161718192021222324252627// ArrayList.javapublic int lastIndexOf(Object o) &#123; return lastIndexOfRange(o, 0, size);&#125;int lastIndexOfRange(Object o, int start, int end) &#123; Object[] es = elementData; // o 为 null 的情况 if (o == null) &#123; for (int i = end - 1; i &gt;= start; i--) &#123; // 倒序 if (es[i] == null) &#123; return i; &#125; &#125; // o 非 null 的情况 &#125; else &#123; for (int i = end - 1; i &gt;= start; i--) &#123; // 倒序 if (o.equals(es[i])) &#123; return i; &#125; &#125; &#125; // 找不到，返回 -1 return -1;&#125; 11.获得指定位置的元素#get(int index) 方法，获得指定位置的元素。代码如下： 123456789101112// ArrayList.javapublic E get(int index) &#123; // 校验 index 不要超过 size Objects.checkIndex(index, size); // 获得 index 位置的元素 return elementData(index);&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 随机访问 index 位置的元素，时间复杂度为 O(1) 。 12. 设置指定位置的元素#set(int index, E element) 方法，设置指定位置的元素。代码如下： 123456789101112// ArrayList.javapublic E set(int index, E element) &#123; // 校验 index 不要超过 size Objects.checkIndex(index, size); // 获得 index 位置的原元素 E oldValue = elementData(index); // 修改 index 位置为新元素 elementData[index] = element; // 返回 index 位置的原元素 return oldValue;&#125; 13.转换成数组#toArray() 方法，将 ArrayList 转换成 [] 数组。代码如下： 1234567891011// ArrayList.javapublic Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;// Arrays.javapublic static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125; 注意，返回的是 Object[] 类型噢。 实际场景下，我们可能想要指定 T 泛型的数组，那么我们就需要使用到 #toArray(T[] a) 方法。代码如下： 123456789101112131415// ArrayList.javapublic &lt;T&gt; T[] toArray(T[] a) &#123; // &lt;1&gt; 如果传入的数组小于 size 大小，则直接复制一个新数组返回 if (a.length &lt; size) // Make a new array of a&#x27;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // &lt;2&gt; 将 elementData 复制到 a 中 System.arraycopy(elementData, 0, a, 0, size); // &lt;2.1&gt; 如果传入的数组大于 size 大小，则将 size 赋值为 null if (a.length &gt; size) a[size] = null; // &lt;2.2&gt; 返回 a return a;&#125; 分成 2 个情况，根据传入的 a数组是否足够大。 &lt;1&gt; 处，如果传入的数组小于 size 大小，则直接复制一个新数组返回。一般情况下，我们不会这么干。 &lt;2&gt; 处，将 elementData 复制到 a 中。 &lt;2.1&gt; 处，如果传入的数组大于 size 大小，则将 size 位置赋值为 null 。额，有点没搞懂这个有啥目的。 &lt;2.2&gt; 处，返回传入的 a 。 考虑到 &lt;1&gt; 处，可能会返回一个新数组，所以即使 &lt;2&gt; 返回的就是 a 数组，最好使用还是按照 a = list.toArray(a) 。 14.求哈希值#hashCode() 方法，求 ArrayList 的哈希值。代码如下： 1234567891011121314151617181920212223242526// ArrayList.javapublic int hashCode() &#123; // 获得当前的数组修改次数 int expectedModCount = modCount; // 计算哈希值 int hash = hashCodeRange(0, size); // 如果修改次数发生改变，则抛出 ConcurrentModificationException 异常 checkForComodification(expectedModCount); return hash;&#125;int hashCodeRange(int from, int to) &#123; final Object[] es = elementData; // 如果 to 超过大小，则抛出 ConcurrentModificationException 异常 if (to &gt; es.length) &#123; throw new ConcurrentModificationException(); &#125; // 遍历每个元素，* 31 求哈希。 int hashCode = 1; for (int i = from; i &lt; to; i++) &#123; Object e = es[i]; hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode()); &#125; return hashCode;&#125; 可能会好奇，为什么使用 31 作为乘子呢？可以看看 《科普：为什么 String hashCode 方法选择数字 31 作为乘子》 。 15. 判断相等#equals(Object o) 方法，判断是否相等。代码如下： 1234567891011121314151617181920212223242526// ArrayList.javapublic boolean equals(Object o) &#123; // 如果是自己，直接返回相等 if (o == this) &#123; return true; &#125; // 如果不为 List 类型，直接不相等 if (!(o instanceof List)) &#123; return false; &#125; // 获得当前的数组修改次数 final int expectedModCount = modCount; // ArrayList can be subclassed and given arbitrary behavior, but we can // still deal with the common case where o is ArrayList precisely // &lt;X&gt; 根据不同类型，调用不同比对的方法。主要考虑 ArrayList 可以直接使用其 elementData 属性，性能更优。 boolean equal = (o.getClass() == ArrayList.class) ? equalsArrayList((ArrayList&lt;?&gt;) o) : equalsRange((List&lt;?&gt;) o, 0, size); // 如果修改次数发生改变，则抛出 ConcurrentModificationException 异常 checkForComodification(expectedModCount); return equal;&#125; 为什么根据类型是否为 ArrayList ，调用了两个不同的方法去比对呢？因为普通的 List ，我们只能使用 Iterator 进行迭代，相比 ArrayList 的 elementData 属性遍历，性能会略低一些。 这两个方法的代码如下，已经添加详细注释。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ArrayList.javaboolean equalsRange(List&lt;?&gt; other, int from, int to) &#123; // 如果 to 大于 es 大小，说明说明发生改变，抛出 ConcurrentModificationException 异常 final Object[] es = elementData; if (to &gt; es.length) &#123; throw new ConcurrentModificationException(); &#125; // 通过迭代器遍历 other ，然后逐个元素对比 var oit = other.iterator(); for (; from &lt; to; from++) &#123; // 如果 oit 没有下一个，或者元素不相等，返回 false 不匹配 if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) &#123; return false; &#125; &#125; // 通过 oit 是否遍历完。实现大小是否相等的效果。 return !oit.hasNext();&#125;private boolean equalsArrayList(ArrayList&lt;?&gt; other) &#123; // 获得 other 数组修改次数 final int otherModCount = other.modCount; final int s = size; boolean equal; // 判断数组大小是否相等 if (equal = (s == other.size)) &#123; final Object[] otherEs = other.elementData; final Object[] es = elementData; // 如果 s 大于 es 或者 otherEs 的长度，说明发生改变，抛出 ConcurrentModificationException 异常 if (s &gt; es.length || s &gt; otherEs.length) &#123; throw new ConcurrentModificationException(); &#125; // 遍历，逐个比较每个元素是否相等 for (int i = 0; i &lt; s; i++) &#123; if (!Objects.equals(es[i], otherEs[i])) &#123; equal = false; break; // 如果不相等，则 break &#125; &#125; &#125; // 如果 other 修改次数发生改变，则抛出 ConcurrentModificationException 异常 other.checkForComodification(otherModCount); return equal;&#125; 16. 清空数组#clear() 方法，清空数组。代码如下： 12345678910// ArrayList.javapublic void clear() &#123; // 获得当前的数组修改次数 modCount++; // 遍历数组，倒序设置为 null final Object[] es = elementData; for (int to = size, i = size = 0; i &lt; to; i++) es[i] = null;&#125; 17. 序列化数组#writeObject(java.io.ObjectOutputStream s) 方法，实现 ArrayList 的序列化。代码如下： 12345678910111213141516171819202122232425262728// ArrayList.java@java.io.Serialprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out element count, and any hidden stuff // 获得当前的数组修改次数 int expectedModCount = modCount; // &lt;1&gt; 写入非静态属性、非 transient 属性 s.defaultWriteObject(); // Write out size as capacity for behavioral compatibility with clone() // &lt;2&gt; 写入 size ，主要为了与 clone 方法的兼容 s.writeInt(size); // Write out all elements in the proper order. // &lt;3&gt; 逐个写入 elementData 数组的元素 for (int i = 0; i &lt; size; i++) &#123; s.writeObject(elementData[i]); &#125; // 如果 other 修改次数发生改变，则抛出 ConcurrentModificationException 异常 if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; &lt;1&gt; 处，调用 ObjectOutputStream#defaultWriteObject() 方法，写入非静态属性、非 transient 属性。《Serializable原理》 &lt;2&gt; 处，写入 size ，主要为了与 clone 方法的兼容。 &lt;3&gt; 处，逐个写入 elementData 元素的数组。回过来看下 elementData 的定义，它是一个 transient 修饰的属性。为什么呢？因为 elementData 数组，并不一定是全满的，而可能是扩容的时候有一定的预留，如果直接序列化，会有很多空间的浪费，所以只序列化从 [0, size) 的元素，减少空间的占用。 18. 反序列化数组#readObject(java.io.ObjectInputStream s) 方法，反序列化数组。代码如下： 1234567891011121314151617181920212223242526272829303132333435// ArrayList.java@java.io.Serialprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff // 读取非静态属性、非 transient 属性 s.defaultReadObject(); // Read in capacity // 读取 size ，不过忽略不用 s.readInt(); // ignored if (size &gt; 0) &#123; // like clone(), allocate array based upon size not capacity SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size); // 不知道作甚，哈哈哈。 // 创建 elements 数组 Object[] elements = new Object[size]; // Read in all elements in the proper order. // 逐个读取 for (int i = 0; i &lt; size; i++) &#123; elements[i] = s.readObject(); &#125; // 赋值给 elementData elementData = elements; &#125; else if (size == 0) &#123; // 如果 size 是 0 ，则直接使用空数组 elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new java.io.InvalidObjectException(&quot;Invalid size: &quot; + size); &#125;&#125; 19. 克隆#clone() 方法，克隆 ArrayList 对象。代码如下： 12345678910111213141516// ArrayList.javapublic Object clone() &#123; try &#123; // 调用父类，进行克隆 ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 拷贝一个新的数组 v.elementData = Arrays.copyOf(elementData, size); // 设置数组修改次数为 0 v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&#x27;t happen, since we are Cloneable throw new InternalError(e); &#125;&#125; 注意，elementData 是重新拷贝出来的新的数组，避免和原数组共享。 20. 创建子数组#subList(int fromIndex, int toIndex) 方法，创建 ArrayList 的子数组。代码如下： 12345678910111213141516171819202122232425262728// ArrayList.javapublic List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList&lt;&gt;(this, fromIndex, toIndex);&#125;private static class SubList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess &#123; /** * 根 ArrayList */ private final ArrayList&lt;E&gt; root; /** * 父 SubList */ private final SubList&lt;E&gt; parent; /** * 起始位置 */ private final int offset; /** * 大小 */ private int size; // ... 省略代码&#125; 实际使用时，一定要注意，SubList 不是一个只读数组，而是和根数组 root 共享相同的 elementData 数组，只是说限制了 [fromIndex, toIndex) 的范围。 21. 创建 Iterator 迭代器#iterator() 方法，创建迭代器。一般情况下，我们使用迭代器遍历 ArrayList、LinkedList 等等 List 的实现类。代码如下： 12345// ArrayList.javapublic Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 创建 Itr 迭代器。Itr 实现 java.util.Iterator 接口，是 ArrayList 的内部类。虽然说 AbstractList 也提供了一个 Itr 的实现，但是 ArrayList 为了更好的性能，所以自己实现了，在其类上也有注释“An optimized version of AbstractList.Itr”。 Itr 一共有 3 个属性，如下： 1234567891011121314151617181920212223// ArrayList.java#Itr/** * 下一个访问元素的位置，从下标 0 开始。 */int cursor; // index of next element to return/** * 上一次访问元素的位置。 * * 1. 初始化为 -1 ，表示无上一个访问的元素 * 2. 遍历到下一个元素时，lastRet 会指向当前元素，而 cursor 会指向下一个元素。这样，如果我们要实现 remove 方法，移除当前元素，就可以实现了。 * 3. 移除元素时，设置为 -1 ，表示最后访问的元素不存在了，都被移除咧。 */int lastRet = -1; // index of last element returned; -1 if no such/** * 创建迭代器时，数组修改次数。 * * 在迭代过程中，如果数组发生了变化，会抛出 ConcurrentModificationException 异常。 */int expectedModCount = modCount;// prevent creating a synthetic constructorItr() &#123;&#125; 下面，来看看 Itr 对 Iterator 的 4 个实现方法。 1.#hasNext() 方法，判断是否还可以继续迭代。代码如下： 12345// ArrayList.java#Itrpublic boolean hasNext() &#123; return cursor != size;&#125; cursor 如果等于 size ，说明已经到数组末尾，无法继续迭代了 2.#next() 方法，返回当前元素。代码如下： 1234567891011121314151617181920212223// ArrayList.java#Itrpublic E next() &#123; // 校验是否数组发生了变化 checkForComodification(); // 判断如果超过 size 范围，抛出 NoSuchElementException 异常 int i = cursor; // &lt;1&gt; i 记录当前 cursor 的位置 if (i &gt;= size) throw new NoSuchElementException(); // 判断如果超过 elementData 大小，说明可能被修改了，抛出 ConcurrentModificationException 异常 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // &lt;2&gt; cursor 指向下一个位置 cursor = i + 1; // &lt;3&gt; 返回当前位置的元素 return (E) elementData[lastRet = i]; // &lt;4&gt; 此处，会将 lastRet 指向当前位置&#125;final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; &lt;1&gt; 处，记录当前 cursor 的位置。因为我们当前返回的就是要求 cursor 位置的元素。 &lt;2&gt; 处，cursor 指向下一个位置。 &lt;3&gt; 处，返回当前位置的元素。同时在 &lt;4&gt; 处，会将 lastRet 指向当前位置。 3.#remove() 方法，移除当前元素。代码如下： 12345678910111213141516171819202122// ArrayList.java#Itrpublic void remove() &#123; // 如果 lastRet 小于 0 ，说明没有指向任何元素，抛出 IllegalStateException 异常 if (lastRet &lt; 0) throw new IllegalStateException(); // 校验是否数组发生了变化 checkForComodification(); try &#123; // &lt;1&gt; 移除 lastRet 位置的元素 ArrayList.this.remove(lastRet); // &lt;2&gt; cursor 指向 lastRet 位置，因为被移了，所以需要后退下 cursor = lastRet; // &lt;3&gt; lastRet 标记为 -1 ，因为当前元素被移除了 lastRet = -1; // &lt;4&gt; 记录新的数组的修改次数 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; &lt;1&gt; 处，调用 #remove(int index) 方法，移除 lastRet 位置的元素。所以要注意，如果移除元素比较前面，会将后面位置的往前挪，即复制，可能比较消耗性能。 &lt;2&gt; 处，cursor 指向 lastRet 位置，因为被移了，所以需要后退下。 &lt;3&gt; 处，lastRet 标记为 -1 ，因为当前元素被移除了。 &lt;4&gt; 处，记录新的数组的修改次数。因为此处修改了数组，如果不修改下，后续迭代肯定会报错。 4.#forEachRemaining(Consumer&lt;? super E&gt; action) 方法，消费剩余未迭代的元素。代码如下： 1234567891011121314151617181920212223242526// ArrayList.java#Itr@Overridepublic void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; // 要求 action 非空 Objects.requireNonNull(action); // 获得当前数组大小 final int size = ArrayList.this.size; // 记录 i 指向 cursor int i = cursor; if (i &lt; size) &#123; // 判断如果超过 elementData 大小，说明可能被修改了，抛出 ConcurrentModificationException 异常 final Object[] es = elementData; if (i &gt;= es.length) throw new ConcurrentModificationException(); // 逐个处理 for (; i &lt; size &amp;&amp; modCount == expectedModCount; i++) action.accept(elementAt(es, i)); // update once at end to reduce heap write traffic // 更新 cursor 和 lastRet 的指向 cursor = i; lastRet = i - 1; // 校验是否数组发生了变化 checkForComodification(); &#125;&#125; 22.创建 ListIterator 迭代器#listIterator(...) 方法，创建 ListIterator 迭代器。代码如下： 12345678910// ArrayList.javapublic ListIterator&lt;E&gt; listIterator(int index) &#123; rangeCheckForAdd(index); return new ListItr(index);&#125;public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; 创建 ListItr 迭代器。ListItr 实现 java.util.ListIterator 接口，是 ArrayList 的内部类。虽然说 AbstractList 也提供了一个 ListItr 的实现，但是 ArrayList 为了更好的性能，所以自己实现了，在其类上也有注释“An optimized version of AbstractList.ListItr”。 ListItr 直接继承 Itr 类，无自定义的属性。代码如下： 123456// ArrayList.java#ListItrListItr(int index) &#123; super(); cursor = index;&#125; 可以手动设置指定的位置开始迭代。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// ArrayList.java#ListItr/** * @return 是否有前一个 */public boolean hasPrevious() &#123; return cursor != 0;&#125;/** * @return 下一个位置 */public int nextIndex() &#123; return cursor;&#125;/** * @return 前一个位置 */public int previousIndex() &#123; return cursor - 1;&#125;/** * @return 前一个元素 */@SuppressWarnings(&quot;unchecked&quot;)public E previous() &#123; // 校验是否数组发生了变化 checkForComodification(); // 判断如果小于 0 ，抛出 NoSuchElementException 异常 int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); // 判断如果超过 elementData 大小，说明可能被修改了，抛出 ConcurrentModificationException 异常 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // cursor 指向上一个位置 cursor = i; // 返回当前位置的元素 return (E) elementData[lastRet = i]; // 此处，会将 lastRet 指向当前位置&#125;/** * 设置当前元素 * * @param e 设置的元素 */public void set(E e) &#123; // 如果 lastRet 无指向，抛出 IllegalStateException 异常 if (lastRet &lt; 0) throw new IllegalStateException(); // 校验是否数组发生了变化 checkForComodification(); try &#123; // 设置 ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125;/** * 添加元素当当前位置 * * @param e 添加的元素 */public void add(E e) &#123; // 校验是否数组发生了变化 checkForComodification(); try &#123; // 添加元素到当前位置 int i = cursor; ArrayList.this.add(i, e); // cursor 指向下一个位置，因为当前位置添加了新的元素，所以需要后挪 cursor = i + 1; // lastRet 标记为 -1 ，因为当前元素并未访问 lastRet = -1; // 记录新的数组的修改次数 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 23.分割迭代器（Spliterator）分割迭代器,是java1.8新提出的能够进行并行遍历的迭代器.用于遍历和分区源元素的对象。Spliterator覆盖的元素源可以是数组， 集合Collection，IO通道或生成器函数。 Spliterator可以单独遍历元素（tryAdvance()）或批量顺序遍历元素（forEachRemaining()）。 代码如下： 12345//ArrayList.java @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; 内部类： 123456789101112131415static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split 存储起始下标; private int fence; // -1 until used; then one past last index 结束下标; private int expectedModCount; // initialized when fence set 修改次数modCount; /** Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125;.....省略方法 getFence方法获取fence结束下标。 123456789101112131415161718private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; //小于0，说明赋值过了，直接返回 if ((hi = fence) &lt; 0) &#123; //空集合，直接赋值0 if ((lst = list) == null) hi = fence = 0; else &#123; //记录修改次数 expectedModCount = lst.modCount; //将集合大小赋值给结束下标 hi = fence = lst.size; &#125; &#125; //返回 return hi; &#125; trySplit方法分割list,返回一个新分割的Spilterator实例；相当于二分法，该方法会递归。 &gt;&gt;&gt;: 无符号右移运算符，num &gt;&gt;&gt; 1，相当于num除以2 123456789public ArrayListSpliterator&lt;E&gt; trySplit() &#123; //hi结束下标，lo开始下标，mid：中间位置 int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; //lo &gt;= mid时，表示不能再分割，返回null //lo &lt; mid时，表示可以分割，切割（lo,mid）出去，相当于取list前半部分返回，同时更新index=mid return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; tryAdvance方法根据action对list 当前元素进行函数式操作，如果存在剩余元素，则对其执行给定操作，返回true；否则返回false。如果此Spliterator为ORDERED，则会对遇见顺序中的下一个元素执行操作。操作抛出的异常会转发给调用者。 如果指定的操作为null则会抛出NullPointerException。 1234567891011121314151617181920public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; //操作为空，抛异常 if (action == null) throw new NullPointerException(); //获取起始下标和结束下标 int hi = getFence(), i = index; if (i &lt; hi) &#123; //起始下标指向下一个元素 index = i + 1; @SuppressWarnings(&quot;unchecked&quot;) E e = (E)list.elementData[i]; //执行操作 action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; //起始下标大于结束下标直接返回false return false; &#125; forEachRemaining方法对list所有元素进行函数式操作。在当前线程中按顺序对每个剩余元素执行给定操作，直到所有元素都已处理或操作抛出异常为止。如果此Spliterator为ORDERED，则会按遇见顺序执行操作。操作抛出的异常会转发给调用者。 说明： 默认实现重复调用tryAdvance(java.util.function.Consumer &lt;? super T&gt;)，直到它返回false。应该尽可能地覆盖它。 123456789101112131415161718192021222324252627public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); //集合不为null，并且集合中数组不为空 if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; //结束下标小于0，将修改次数赋值给mc，集合大小赋值给hi if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; //起始下标大于等于0，结束下标小于等于数组长度 if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; //遍历元素进行指定操作 for (; i &lt; hi; ++i) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; estimateSize方法返回长度，估算大小，如果无限，未知或计算成本太高，则返回Long.MAX_VALUE。 123public long estimateSize() &#123; return (long) (getFence() - index); &#125; characteristics方法返回特征值：ORDERED、SIZED、SUBSIZED。 ORDERED = 0x00000010 SIZED = 0x00000040; SUBSIZED = 0x00004000 1234public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;&#125; 使用案例123456789101112131415161718192021222324public class SpliteratorTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100 ; i++) &#123; list.add(i+&quot;&quot;); &#125; // 分割迭代器 Spliterator spliterator = list.spliterator(); Spliterator s1 = spliterator.trySplit(); Spliterator s2 = spliterator.trySplit(); System.out.println(&quot;===============spliterator================&quot;); spliterator.forEachRemaining((i) -&gt; System.out.print(i+&quot; &quot;)); System.out.println(); System.out.println(&quot;===============s1================&quot;); s1.forEachRemaining((i) -&gt; System.out.print(i+&quot; &quot;)); System.out.println(); System.out.println(&quot;===============s2================&quot;); s2.forEachRemaining((i) -&gt; System.out.print(i+&quot; &quot;)); System.out.println(); &#125;&#125; 运行结果： 24.removeIf方法removeIf() 方法用于删除所有满足特定条件的数组元素。 removeIf() 方法的语法为：arraylist.removeIf(Predicate&lt;E&gt; filter) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; //记录被删除元素的下标 final BitSet removeSet = new BitSet(size); //修改次数 final int expectedModCount = modCount; //集合大小 final int size = this.size; //遍历把符合条件的待删除的元素下标设置到BitSet中，即BitSet中对应的下标设为true. for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; //检查是否有其他线程并发修改该ArrayList if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; //符合条件的元素&gt;0 if (anyToRemove) &#123; //新的集合大小 final int newSize = size - removeCount; //移除相应元素 for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; //通过nextClearBit(i) 为返回下一个false位置,即表示下标i是无需移除的元素 i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; //newSize之后的元素置空 for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove;&#125; 25.replaceAll方法根据UnaryOperator对象操作list(函数式) 12345678910111213141516public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; //判断operator是否为空 Objects.requireNonNull(operator); // final int expectedModCount = modCount; final int size = this.size; //循环条件expectedModCount==modCount&amp;&amp; i&lt;size,防止并发的时候，modCount被其他线程修改 for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; //执行操作 elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; 26.sort方法根据比较器对list进行排序 12345678public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 27.forEach方法对list进行函数式循环（重写Iterable接口中的方法） 123456789101112131415public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); //修改次数 final int expectedModCount = modCount; @SuppressWarnings(&quot;unchecked&quot;) final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; //执行操作 action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 小结 ArrayList 是基于 [] 数组实现的 List 实现类，支持在数组容量不够时，一般按照 1.5 倍自动扩容。同时，它支持手动扩容、手动缩容。 ArrayList 随机访问时间复杂度是 O(1) ，查找指定元素的平均时间复杂度是 O(n) 时间复杂度的计算方式可以看看《算法复杂度分析（上）：分析算法运行时，时间资源及空间资源的消耗》 和 《算法复杂度分析（下）：最好、最坏、平均、均摊等时间复杂度概述》 两文。 ArrayList 移除指定位置的元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。 最好时间复杂度发生在末尾移除的情况。 ArrayList 移除指定元素的时间复杂度是 O(n) 。 因为首先需要进行查询，然后在使用移除指定位置的元素，无论怎么计算，都需要 O(n) 的时间复杂度。 ArrayList 添加元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。 最好时间复杂度发生在末尾添加的情况。 Redis String 的数据结构，实现方式是类似 Java ArrayList 的方式 链表 LinkedListLinkedList ，基于节点实现的双向链表的 List ，每个节点都指向前一个和后一个节点从而形成链表。 1.类图 下面 3 个接口是 ArrayList 一致的： java.util.List 接口 java.io.Serializable 接口 java.lang.Cloneable 接口 下面 1 个接口是少于 ArrayList 的： java.util.RandomAccess 接口，LinkedList 不同于 ArrayList 的很大一点，==不支持随机访问==。 如下1 个接口是多于 ArrayList 的： java.util.Deque 接口，提供双端队列的功能，LinkedList 支持快速的在头尾添加元素和读取元素，所以很容易实现该特性。 因为LinkedList 实现了 Deque 接口，添加或者移除一个元素会有多种方法；可以作为队列使用，也可以作为栈使用，还可以作为双端队列。 2.属性 通过 Node 节点指向前后节点，从而形成双向链表。 first和last属性：链表的头尾指针。 在初始时候，first 和 last 指向 null ，因为此时暂时没有 Node 节点。 在添加完首个节点后，创建对应的 Node 节点 node1 ，前后指向 null 。此时，first 和 last 指向该 Node 节点。 继续添加一个节点后，创建对应的 Node 节点 node2 ，其 prev = node1 和 next = null ，而 node1 的 prev = null 和 next = node2 。此时，first 保持不变，指向 node1 ，last 发生改变，指向 node2 。 size 属性：链表的节点数量。通过它进行计数，避免每次需要 List 大小时，从头到尾的遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// LinkedList.java/** * 链表大小 */transient int size = 0;/** * 头节点 * * Pointer to first node. */transient Node&lt;E&gt; first;/** * 尾节点 * * Pointer to last node. */transient Node&lt;E&gt; last;/** * 节点 * * @param &lt;E&gt; 元素泛型 */private static class Node&lt;E&gt; &#123; /** * 元素 */ E item; /** * 前一个节点 */ Node&lt;E&gt; next; /** * 后一个节点 */ Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 3.构造方法LinkedList 一共有两个构造方法 1234567public LinkedList() &#123; &#125; public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 4. 添加单个元素1.添加单个元素到末尾 #add(E e) 方法，顺序添加单个元素到链表。代码如下： 1234567891011121314151617181920212223242526272829// LinkedList.javapublic boolean add(E e) &#123; // &lt;X&gt; 添加末尾 linkLast(e); return true;&#125;void linkLast(E e) &#123; // &lt;1&gt; 记录原 last 节点 final Node&lt;E&gt; l = last; // &lt;2&gt; 创建新节点 // 第一个参数表示，newNode 的前一个节点为 l 。 // 第二个参数表示，e 为元素。 // 第三个参数表示，newNode 的后一个节点为 null 。 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // &lt;3&gt; last 指向新节点 last = newNode; // &lt;4.1&gt; 如果原 last 为 null ，说明 first 也为空，则 first 也指向新节点 if (l == null) first = newNode; // &lt;4.2&gt; 如果原 last 非 null ，说明 first 也非空，则原 last 的 next 指向新节点。 else l.next = newNode; // &lt;5&gt; 增加链表大小 size++; // &lt;6&gt; 增加数组修改次数 modCount++;&#125; &lt;X&gt; 处，调用 #linkLast(E e) 方法，将新元素添加到链表的尾巴。所以，#add(E e) 方法，实际就是 #linkLast(E e) 方法。 总体来说，代码实现比较简单。重点就是对 last 的处理。 相比 ArrayList 来说，无需考虑容量不够时的扩容。 2.添加元素到指定位置 看看 #add(int index, E element) 方法，插入单个元素到指定位置。代码如下： 12345678910111213// LinkedList.javapublic void add(int index, E element) &#123; // 校验不要超过范围 checkPositionIndex(index); // &lt;1&gt; 如果刚好等于链表大小，直接添加到尾部即可 if (index == size) linkLast(element); // &lt;2&gt; 添加到第 index 的节点的前面 else linkBefore(element, node(index));&#125; &lt;1&gt; 处，如果刚好等于链表大小，直接调用 #linkLast(E element) 方法，添加到尾部即可。 &lt;2&gt; 处，先调用 #node(int index) 方法，获得第 index 位置的 Node 节点 node 。然后，调用 #linkBefore(E element, Node node) 方法，将新节点添加到 node 的前面。相当于说，node 的前一个节点的 next 指向新节点，node 的 prev 指向新节点。 #node(int index) 方法，获得第 index 个 Node 节点。代码如下： 12345678910111213141516171819// LinkedList.javaNode&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 如果 index 小于 size 的一半，就正序遍历，获得第 index 个节点 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; // 如果 index 大于 size 的一半，就倒序遍历，获得第 index 个节点 &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; #linkBefore(E e, Node&lt;E&gt; succ) 方法，添加元素 e 到 succ 节点的前面。代码如下： 123456789101112131415161718192021// LinkedList.javavoid linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 获得 succ 的前一个节点 final Node&lt;E&gt; pred = succ.prev; // 创建新的节点 newNode final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // &lt;Y&gt; 设置 succ 的前一个节点为新节点 succ.prev = newNode; // 如果 pred 为 null ，说明 first 也为空，则 first 也指向新节点 if (pred == null) first = newNode; // 如果 pred 非 null ，说明 first 也为空，则 pred 也指向新节点 else pred.next = newNode; // 增加链表大小 size++; // 增加数组修改次数 modCount++;&#125; 3.添加元素到链表头或尾 因为 LinkedList 实现了 Deque 接口，所以它实现了 #addFirst(E e) 和 #addLast(E e) 方法，分别添加元素到链表的头尾。代码如下： 1234567891011121314151617// LinkedList.java 实现 Deque 接口public void addFirst(E e) &#123; linkFirst(e);&#125;public boolean offerFirst(E e) &#123; addFirst(e); // 调用上面的方法 return true;&#125;public void addLast(E e) &#123; linkLast(e);&#125;public boolean offerLast(E e) &#123; addLast(e); // 调用上面的方法 return true;&#125; #linkLast(E e) 方法，和 #add(E e) 方法是一致的。 #addFirst(E e) 方法，调用 #linkFirst(E e) 方法，添加元素到队头。代码如下： 1234567891011121314151617181920// LinkedList.javaprivate void linkFirst(E e) &#123; // 记录原 first 节点 final Node&lt;E&gt; f = first; // 创建新节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // first 指向新节点 first = newNode; // 如果原 first 为空，说明 last 也为空，则 last 也指向新节点 if (f == null) last = newNode; // 如果原 first 非空，说明 last 也非空，则原 first 的 next 指向新节点。 else f.prev = newNode; // 增加链表大小 size++; // 增加数组修改次数 modCount++;&#125; 因为 LinkedList 实现了 Queue 接口，所以它实现了 #push(E e) 和 #offer(E e) 方法，添加元素到链表的头尾。代码如下： 123456789// LinkedList.java 实现 Queue 接口public void push(E e) &#123; addFirst(e);&#125;public boolean offer(E e) &#123; return add(e);&#125; 总的来说，添加单个元素，分成三个情况： 添加元素到队头 添加元素到队尾 添加元素到中间 5.链表扩容LinkedList 不存在扩容的需求，因为通过 Node 的前后指向即可。 6.添加多个元素#addAll(Collection&lt;? extends E&gt; c) 方法，批量添加多个元素。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// LinkedList.javapublic boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); // &lt;1&gt; 将 c 转成 a 数组 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) // 如果无添加元素，直接返回 false 数组未变更 return false; // &lt;2&gt; 获得第 index 位置的节点 succ ，和其前一个节点 pred Node&lt;E&gt; pred, succ; if (index == size) &#123; // 如果 index 就是链表大小，那说明插入队尾，所以 succ 为 null ，pred 为 last 。 succ = null; pred = last; &#125; else &#123; // 如果 index 小于链表大小，则 succ 是第 index 个节点，prev 是 succ 的前一个二节点。 succ = node(index); pred = succ.prev; &#125; // &lt;3&gt; 遍历 a 数组，添加到 pred 的后面 for (Object o : a) &#123; // 创建新节点 @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); // 如果 pred 为 null ，说明 first 也为 null ，则直接将 first 指向新节点 if (pred == null) first = newNode; // pred 下一个指向新节点 else pred.next = newNode; // 修改 pred 指向新节点 pred = newNode; &#125; // &lt;4&gt; 修改 succ 和 pred 的指向 if (succ == null) &#123; // 如果 succ 为 null ，说明插入队尾，则直接修改 last 指向最后一个 pred last = pred; &#125; else &#123; // 如果 succ 非 null ，说明插入到 succ 的前面 pred.next = succ; // prev 下一个指向 succ succ.prev = pred; // succes 前一个指向 pred &#125; // &lt;5&gt; 增加链表大小 size += numNew; // &lt;6&gt; 增加数组修改次数 modCount++; // 返回 true 数组有变更 return true;&#125; #addAll(Collection&lt;? extends E&gt; c) 方法，其内部调用的是 #addAll(int index, Collection&lt;? extends E&gt; c) 方法，表示在队列之后，继续添加 c 集合。 &lt;2&gt; 处，获得第 index 位置的节点 succ ，和其前一个节点 pred 。分成两种情况，实际上，ArrayList 在添加 c 集合的时候，也是分成跟 LinkedList 一样的两种情况，只是说 LinkedList 在一个方法统一实现了。 &lt;3&gt; 处，遍历 a 数组，添加到 pred 的后面。其实，我们可以把 pred 理解成“尾巴”，然后不断的指向新节点，而新节点又称为新的 pred 尾巴。如此反复插入~ &lt;4&gt; 处，修改 succ 和 pred 的指向。根据 &lt;2&gt; 处分的两种情况，进行处理。 7.移除单个元素1.移除指定位置元素 #remove(int index) 方法，移除指定位置的元素，并返回该位置的原元素。代码如下： 1234567// LinkedList.javapublic E remove(int index) &#123; checkElementIndex(index); // 获得第 index 的 Node 节点，然后进行移除。 return unlink(node(index));&#125; 首先，调用 #node(int index) 方法，获得第 index 的 Node 节点。然后偶，调用 #unlink(Node&lt;E&gt; x) 方法，移除该节点。 #unlink(Node&lt;E&gt; x) 方法，代码如下： 123456789101112131415161718192021222324252627282930313233// LinkedList.javaE unlink(Node&lt;E&gt; x) &#123; // assert x != null; // &lt;1&gt; 获得 x 的前后节点 prev、next final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; // &lt;2&gt; 将 prev 的 next 指向下一个节点 if (prev == null) &#123; // &lt;2.1&gt; 如果 prev 为空，说明 first 被移除，则直接将 first 指向 next first = next; &#125; else &#123; // &lt;2.2&gt; 如果 prev 非空 prev.next = next; // prev 的 next 指向 next x.prev = null; // x 的 pre 指向 null &#125; // &lt;3&gt; 将 next 的 prev 指向上一个节点 if (next == null) &#123; // &lt;3.1&gt; 如果 next 为空，说明 last 被移除，则直接将 last 指向 prev last = prev; &#125; else &#123; // &lt;3.2&gt; 如果 next 非空 next.prev = prev; // next 的 prev 指向 prev x.next = null; // x 的 next 指向 null &#125; // &lt;4&gt; 将 x 的 item 设置为 null ，帮助 GC x.item = null; // &lt;5&gt; 减少链表大小 size--; // &lt;6&gt; 增加数组的修改次数 modCount++; return element;&#125; &lt;2&gt; 处，将 prev 的 next 指向下一个节点。其中，&lt;2.1&gt; 处，是移除队头 first 的情况。 &lt;3&gt; 处，将 next 的 prev 指向上一个节点。其中，&lt;3.1&gt; 处，如果 next 为空，说明队尾 last 被移除的情况。 2.移除首个元素 #remove(Object o) 方法，移除首个为 o 的元素，并返回是否移除到。代码如下： 12345678910111213141516171819202122// LinkedList.javapublic boolean remove(Object o) &#123; if (o == null) &#123; // o 为 null 的情况 // 顺序遍历，找到 null 的元素后，进行移除 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; // 顺序遍历，找到等于 o 的元素后，进行移除 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 相比 #remove(int index) 方法来说，需要去寻找首个等于 o 的节点进行移除。当然，最终还是调用 #unlink(Node&lt;E&gt; x) 方法，移除该节点。 3.移除首个、末尾元素 #removeFirstOccurrence(Object o) 和 #removeLastOccurrence(Object o) 方法，分别实现移除链表首个节点和最后节点。代码如下： 1234567891011121314151617181920212223242526// LinkedList.java 实现 Deque 接口public boolean removeFirstOccurrence(Object o) &#123; // 移除首个 return remove(o);&#125;public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; // o 为 null 的情况 // 倒序遍历，找到 null 的元素后，进行移除 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; // 倒序遍历，找到等于 o 的元素后，进行移除 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; #remove() 方法，移除链表首个节点。代码如下： 12345678910111213141516171819202122232425262728293031323334353637// LinkedList.java 实现 Queue 接口public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; // &lt;1&gt; 如果链表为空，抛出 NoSuchElementException 异常 if (f == null) throw new NoSuchElementException(); // &lt;2&gt; 移除链表时首个元素 return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; // 获得 f 的下一个节点 final Node&lt;E&gt; next = f.next; // 设置 f 的 item 为 null ，帮助 GC f.item = null; // 设置 f 的 next 为 null ，帮助 GC f.next = null; // help GC // 修改 fisrt 指向 next first = next; // 修改 next 节点的 prev 指向 null if (next == null) // 如果链表只有一个元素，说明被移除后，队列就是空的，则 last 设置为 null last = null; else next.prev = null; // 链表大小减一 size--; // 增加数组修改次数 modCount++; return element;&#125; &lt;1&gt; 处，如果链表为空，抛出 NoSuchElementException 异常。 &lt;2&gt; 处，移除链表时首个元素。因为 LinkedList 有 first 和 last 头尾节点，所以添加和删除操作，都可能需要小心处理。 4.移除末尾节点 #removeLast() 方法，移除链表最后一个节点。代码如下： 123456789101112131415161718192021222324252627282930313233// LinkedList.java 实现 Deque 接口public E removeLast() &#123; final Node&lt;E&gt; l = last; // 如果链表为空，则抛出 NoSuchElementException 移除 if (l == null) throw new NoSuchElementException(); // 移除链表的最后一个元素 return unlinkLast(l);&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; // 获得 f 的上一个节点 final Node&lt;E&gt; prev = l.prev; // 设置 l 的 item 为 null ，帮助 GC l.item = null; // 设置 l 的 prev 为 null ，帮助 GC l.prev = null; // help GC // 修改 last 指向 prev last = prev; // 修改 prev 节点的 next 指向 null if (prev == null) // 如果链表只有一个元素，说明被移除后，队列就是空的，则 first 设置为 null first = null; else prev.next = null; // 链表大小减一 size--; // 增加数组修改次数 modCount++; return element;&#125; 5.移除链表的头或尾 #poll() 方法，移除链表的头或尾，差异点在于链表为空时候，不会抛出 NoSuchElementException 异常。代码如下： 12345678910111213141516171819202122// LinkedList.java 实现 Queue 接口public E poll() &#123; // 移除头 final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public E pop() &#123; return removeFirst(); // 这个方法，如果队列为空，还是会抛出 NoSuchElementException 异常。&#125;// LinkedList.java 实现 Deque 接口public E pollFirst() &#123; // 移除头 final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public E pollLast() &#123; // 移除尾 final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 8.移除多个元素#removeAll(Collection&lt;?&gt; c) 方法，批量移除指定的多个元素。代码如下： 1234567891011121314151617// AbstractCollection.javapublic boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; // 获得迭代器 Iterator&lt;?&gt; it = iterator(); // 通过迭代器遍历 while (it.hasNext()) &#123; // 如果 c 中存在该元素，则进行移除 if (c.contains(it.next())) &#123; it.remove(); modified = true; // 标记修改 &#125; &#125; return modified;&#125; 该方法，是通过父类 AbstractCollection 来实现的，通过迭代器来遍历 LinkedList ，然后判断 c 中如果包含，则进行移除。 #retainAll(Collection&lt;?&gt; c) 方法，求 LinkedList 和指定多个元素的交集。简单来说，恰好和 #removeAll(Collection&lt;?&gt; c) 相反，移除不在 c 中的元素。代码如下： 1234567891011121314151617// AbstractCollection.javapublic boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); boolean modified = false; // 获得迭代器 Iterator&lt;E&gt; it = iterator(); // 通过迭代器遍历 while (it.hasNext()) &#123; // &lt;X&gt; 如果 c 中不存在该元素，则进行移除 if (!c.contains(it.next())) &#123; it.remove(); modified = true; &#125; &#125; return modified;&#125; 9.查找单个元素#indexOf(Object o) 方法，查找首个为指定元素的位置。代码如下： 12345678910111213141516171819202122// LinkedList.javapublic int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; // 如果 o 为 null 的情况 // 顺序遍历，如果 item 为 null 的节点，进行返回 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; // 找到 index++; &#125; &#125; else &#123; // 如果 o 非 null 的情况 // 顺序遍历，如果 item 为 o 的节点，进行返回 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; // 找到 index++; &#125; &#125; // 未找到 return -1;&#125; 而 #contains(Object o) 方法，就是基于该方法实现。代码如下： 12345// LinkedList.javapublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 有时我们需要查找最后一个为指定元素的位置，所以会使用到 #lastIndexOf(Object o) 方法。代码如下： 12345678910111213141516171819202122// LinkedList.javapublic int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; // 如果 o 为 null 的情况 // 倒序遍历，如果 item 为 null 的节点，进行返回 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; // 找到 &#125; &#125; else &#123; // 如果 o 非 null 的情况 // 倒序遍历，如果 item 为 o 的节点，进行返回 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; // 找到 &#125; &#125; // 未找到 return -1;&#125; 10.获得指定位置的元素1.获取指定位置元素 #get(int index) 方法，获得指定位置的元素。代码如下： 1234567// LinkedList.javapublic E get(int index) &#123; checkElementIndex(index); // 基于 node(int index) 方法实现 return node(index).item;&#125; 随机访问 index 位置的元素，时间复杂度为 O(n) 。 2.获取头尾元素 因为 LinkedList 实现了 Deque 接口，所以它实现了 #peekFirst() 和 #peekLast() 方法，分别获得元素到链表的头尾。代码如下： 1234567891011// LinkedList.java 实现 Deque 接口public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125; 3.获取头元素 因为 LinkedList 实现了 Queue 接口，所以它实现了 #peek() 和 #element() 方法，分别获得元素到链表的头。代码如下： 12345678910111213141516// LinkedList.java 实现 Queue 接口public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E element() &#123; // 如果链表为空识，抛出 NoSuchElementException 异常 return getFirst();&#125;public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) // 如果链表为空识，抛出 NoSuchElementException 异常 throw new NoSuchElementException(); return f.item;&#125; 11.设置指定位置的元素#set(int index, E element) 方法，设置指定位置的元素。代码如下： 1234567891011// LinkedList.javapublic E set(int index, E element) &#123; checkElementIndex(index); // 获得第 index 位置的节点 Node&lt;E&gt; x = node(index); E oldVal = x.item; // 修改对应的值 x.item = element; return oldVal;&#125; 12.转换成数组1.object类型数组 #toArray() 方法，将LinkedList 转换成 [] 数组。代码如下： 1234567891011// LinkedList.javapublic Object[] toArray() &#123; // 创建 Object 数组 Object[] result = new Object[size]; // 顺序遍历节点，设置到 Object 数组中 int i = 0; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; return result;&#125; 2.指定类型数组 实际场景下，我们可能想要指定 T 泛型的数组，那么我们就需要使用到 #toArray(T[] a) 方法。代码如下： 1234567891011121314151617181920// LinkedList.javapublic &lt;T&gt; T[] toArray(T[] a) &#123; // &lt;1&gt; 如果传入的数组小于 size 大小，则直接复制一个新数组返回 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // &lt;2&gt; 顺序遍历链表，复制到 a 中 int i = 0; Object[] result = a; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; // &lt;2.1&gt; 如果传入的数组大于 size 大小，则将 size 赋值为 null if (a.length &gt; size) a[size] = null; // &lt;2.2&gt; 返回 a return a;&#125; 13.求哈希值#hashCode() 方法，求 LinkedList 的哈希值。代码如下： 123456789// AbstractList.javapublic int hashCode() &#123; int hashCode = 1; // 遍历，求哈希 for (E e : this) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); return hashCode;&#125; 该方法，是通过父类 AbstractList 来实现的，通过 for 来遍历 LinkedList ，然后进行求哈希。它最终会编译转换成 Iterator 迭代器。 14.判断相等#equals(Object o) 方法，判断是否相等。代码如下： 12345678910111213141516171819202122// AbstractList.javapublic boolean equals(Object o) &#123; // 如果 o 就是自己，直接返回 true if (o == this) return true; // 如果不为 List 类型，直接返回 false if (!(o instanceof List)) return false; // 创建迭代器，顺序遍历比对 ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) &#123; E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) // 如果不相等，返回 false return false; &#125; // 如果有迭代器没有遍历完，说明两者长度不等，所以就不相等；否则，就相等了 return !(e1.hasNext() || e2.hasNext());&#125; 该方法，是通过父类 AbstractList 来实现的，通过迭代器，实现遍历比对。 15.清空链表#clear() 方法，清空链表。代码如下： 1234567891011121314151617181920212223242526// LinkedList.javapublic void clear() &#123; // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator // 顺序遍历链表，设置每个节点前后指向为 null // 通过这样的方式，帮助 GC for (Node&lt;E&gt; x = first; x != null; ) &#123; // 获得下一个节点 Node&lt;E&gt; next = x.next; // 设置 x 的 item、next、prev 为空。 x.item = null; x.next = null; x.prev = null; // 设置 x 为下一个节点 x = next; &#125; // 清空 first 和 last 指向 first = last = null; // 设置链表大小为 0 size = 0; // 增加数组修改次数 modCount++;&#125; 16.序列化链表#writeObject(java.io.ObjectOutputStream s) 方法，实现 LinkedList 的序列化。代码如下： 123456789101112131415161718// LinkedList.java@java.io.Serialprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic // 写入非静态属性、非 transient 属性 s.defaultWriteObject(); // Write out size // 写入链表大小 s.writeInt(size); // Write out all elements in the proper order. // 顺序遍历，逐个序列化 for (Node&lt;E&gt; x = first; x != null; x = x.next) s.writeObject(x.item);&#125; 17.反序列化链表#readObject(java.io.ObjectInputStream s) 方法，反序列化数组。代码如下： 123456789101112131415161718// LinkedList.java@java.io.Serialprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic // 读取非静态属性、非 transient 属性 s.defaultReadObject(); // Read in size // 读取 size int size = s.readInt(); // Read in all elements in the proper order. // 顺序遍历，逐个反序列化 for (int i = 0; i &lt; size; i++) linkLast((E)s.readObject()); // 添加到链表尾部&#125; 18.克隆#clone() 方法，克隆 LinkedList 对象。代码如下： 12345678910111213141516171819// LinkedList.javapublic Object clone() &#123; // 调用父类，进行克隆 LinkedList&lt;E&gt; clone = superClone(); // Put clone into &quot;virgin&quot; state // 重置 clone 为初始化状态 clone.first = clone.last = null; clone.size = 0; clone.modCount = 0; // Initialize clone with our elements // 遍历遍历，逐个添加到 clone 中 for (Node&lt;E&gt; x = first; x != null; x = x.next) clone.add(x.item); return clone;&#125; 注意，first、last 等都是重新初始化进来，不与原 LinkedList 共享。 19.创建子数组#subList(int fromIndex, int toIndex) 方法，创建 ArrayList 的子数组。代码如下： 123456789// AbstractList.javapublic List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size()); // 根据判断 RandomAccess 接口，判断是否支持随机访问 return (this instanceof RandomAccess ? new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) : new SubList&lt;&gt;(this, fromIndex, toIndex));&#125; 该方法，是通过父类 AbstractList 来实现的。 根据判断 RandomAccess 接口，判断是否支持随机访问，从而创建 RandomAccessSubList 或 SubList 对象 20.创建 Iterator 迭代器#iterator() 方法，创建迭代器。代码如下： 12345678910111213// AbstractSequentialList.javapublic Iterator&lt;E&gt; iterator() &#123; return listIterator();&#125;// AbstractList.javapublic ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0);&#125;// AbstractSequentialList.javapublic abstract ListIterator&lt;E&gt; listIterator(int index); 该方法，是通过父类 AbstractSequentialList 来实现的。 整个调用过程是，iterator() =&gt; listIterator() =&gt; listIterator(int index) 的顺序，就是我们在代码里贴进去的顺序。 21.创建 ListIterator 迭代器#listIterator(int index) 方法，创建 ListIterator 迭代器。代码如下： 123456// LinkedList.javapublic ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; 创建ListItr迭代器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// LinkedList.javaprivate class ListItr implements ListIterator&lt;E&gt; &#123; /** * 最后返回的节点 */ private Node&lt;E&gt; lastReturned; /** * 下一个节点 */ private Node&lt;E&gt; next; /** * 下一个访问元素的位置，从下标 0 开始。 * * 主要用于 &#123;@link #nextIndex()&#125; 中，判断是否遍历结束 */ private int nextIndex; /** * 创建迭代器时，数组修改次数。 * * 在迭代过程中，如果数组发生了变化，会抛出 ConcurrentModificationException 异常。 */ private int expectedModCount = modCount; ListItr(int index) &#123; // assert isPositionIndex(index); // 获得下一个节点 next = (index == size) ? null : node(index); // 下一个节点的位置 nextIndex = index; &#125; public boolean hasNext() &#123; return nextIndex &lt; size; &#125; public E next() &#123; // 校验是否数组发生了变化 checkForComodification(); // 如果已经遍历到结尾，抛出 NoSuchElementException 异常 if (!hasNext()) throw new NoSuchElementException(); // lastReturned 指向，记录最后访问节点 lastReturned = next; // next 指向，下一个节点 next = next.next; // 下一个节点的位置 + 1 nextIndex++; // 返回 lastReturned return lastReturned.item; &#125; public boolean hasPrevious() &#123; return nextIndex &gt; 0; &#125; public E previous() &#123; // 校验是否数组发生了变化 checkForComodification(); // 如果已经遍历到结尾，抛出 NoSuchElementException 异常 if (!hasPrevious()) throw new NoSuchElementException(); // 修改 lastReturned 和 next 的指向。此时，lastReturned 和 next 是相等的。 lastReturned = next = (next == null) ? last : next.prev; // 下一个节点的位置 - 1 nextIndex--; // 返回 lastReturned return lastReturned.item; &#125; public int nextIndex() &#123; return nextIndex; &#125; public int previousIndex() &#123; return nextIndex - 1; &#125; public void remove() &#123; // 校验是否数组发生了变化 checkForComodification(); // 如果 lastReturned 为空，抛出 IllegalStateException 异常，因为无法移除了。 if (lastReturned == null) throw new IllegalStateException(); // 获得 lastReturned 的下一个 Node&lt;E&gt; lastNext = lastReturned.next; // 移除 lastReturned 节点 unlink(lastReturned); // 此处，会分成两种情况 if (next == lastReturned) // 说明发生过调用 `#previous()` 方法的情况，next 指向下一个节点，而 nextIndex 是无需更改的 next = lastNext; else nextIndex--; // nextIndex 减一。 // 设置 lastReturned 为空 lastReturned = null; // 增加数组修改次数 expectedModCount++; &#125; public void set(E e) &#123; // 如果 lastReturned 为空，抛出 IllegalStateException 异常，因为无法修改了。 if (lastReturned == null) throw new IllegalStateException(); // 校验是否数组发生了变化 checkForComodification(); // 修改 lastReturned 的 item 为 e lastReturned.item = e; &#125; public void add(E e) &#123; // 校验是否数组发生了变化 checkForComodification(); // 设置 lastReturned 为空 lastReturned = null; // 此处，会分成两种情况 if (next == null) // 如果 next 已经遍历到尾，则 e 作为新的尾节点，进行插入。算是性能优化 linkLast(e); else // 插入到 next 的前面 linkBefore(e, next); // nextIndex 加一。 nextIndex++; // 增加数组修改次数 expectedModCount++; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); // 遍历剩余链表 while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) &#123; // 执行 action 逻辑 action.accept(next.item); // lastReturned 指向 next lastReturned = next; // next 指向下一个节点 next = next.next; // nextIndex 加一。 nextIndex++; &#125; // 校验是否数组发生了变化 checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 小结 LinkedList 基于节点实现的双向链表的 List ，每个节点都指向前一个和后一个节点从而形成链表。 LinkedList 提供队列、双端队列、栈的功能。 因为 first 节点，所以提供了队列的功能的实现的功能。因为 last 节点，所以提供了栈的功能的实现的功能。因为同时具有 first + last 节点，所以提供了双端队列的功能。 LinkedList 随机访问平均时间复杂度是 O(n) ，查找指定元素的平均时间复杂度是 O(n) 。 LinkedList 移除指定位置的元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。 最好时间复杂度发生在头部、或尾部移除的情况。 LinkedList 移除指定位置的元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。 最好时间复杂度发生在头部移除的情况。 LinkedList 添加元素的最好时间复杂度是 O(1) ，最坏时间复杂度是 O(n) ，平均时间复杂度是 O(n) 。 最好时间复杂度发生在头部、或尾部添加的情况。 因为 LinkedList 提供了多种添加、删除、查找的方法，会根据是否能够找到对应的元素进行操作，抛出 NoSuchElementException 异常。整理了一个表格，避免错误使用。 返回结果 抛出异常 添加 #add(…)、#offset(...) 删除 #remove(int index)、#remove(E e)、#poll(E E) #remove() 查找 #get(int index)、#peek() #poll() 这个表主要整理了 List 和 Queue 的操作，暂时没有整理 Deque 的操作。因为，Deque 相同前缀的方法，表现结果同 Queue 。 拓展，在 Redis List 的数据结构，实现方式是类似 Java LinkedList 的方式 哈希表 HashMap1.简介HashMap ，是一种散列表，用于存储 key-value 键值对的数据结构，一般翻译为“哈希表”，提供平均时间复杂度为 O(1) 的、基于 key 级别的 get/put 等操作。 在日常的业务开发中，HashMap 可以说是和 ArrayList 一样常用的集合类，特别是考虑到数据库的性能，又或者服务的拆分后，我们把关联数据的拼接，放到了内存中，这就需要使用到 HashMap 了。 2. 类图HashMap 实现的接口、继承的抽象类，如下图所示： 实现 java.util.Map 接口，并继承 java.util.AbstractMap 抽像类。 实现 java.io.Serializable 接口。 实现 java.lang.Cloneable 接口。 3. 属性在初次看到 HashMap 时，惊奇于其 O(1) 的 get 操作的时间复杂度。当时在我们已知的数据结构中，只有基于下标访问数组时，才能提供 O(1) get 操作的时间复杂度。 实际上，HashMap 所提供的 O(1) 是平均时间复杂度，大多数情况下保证 O(1) 。其实极端情况下，有可能退化为 O(N) 的时间复杂度噢，这又是为什么呢？ 基础实现 HashMap 其实是在数组的基础上实现的，一个“加强版”的数组。如下图所示： key如果是一个整数，可以放入指向数组中的指定下标，但是key并不是整数。所以，hash 就正式登场了，通过 hash(key) 的过程，可以将 key 成功的转成一个整数。但是，hash(key) 可能会超过数组的容量，所以需要 hash(key) % size 作为下标，放入数组的对应位置。至此，是不是已经可以通过 O(1) 的方式，快速的从 HashMap 中进行 get 读取操作了。 注意，一般每个数组的“位置”，比较专业的说法，叫做“槽位”（slot）或者“桶”。 保证唯一 其实上述还是不太对，原因有两点： 1、hash(key) 计算出来的哈希值，并不能保证唯一； 2、hash(key) % size 的操作后，即使不同的哈希值，也可能变成相同的结果。 这样，就导致我们常说的“哈希冲突”。那么怎么解决呢？方法有两种： 开放寻址法 链表法 在 Java HashMap 中，采用了链表法。 Redis Hash 数据结构也是采用了链表法。通过将数组的每个元素对应一个链表，将相同的 hash(key) % size 放到对应下标的链表中即可，put / get操作需要做下是否等于指定 key 的判断。 解决极端情况 其实上述还是会出现O(N) 的时间复杂度的情况,如果我们放入的 N 个 key-value 键值对到 HashMap 的情况： 1、每个 key 经过 hash(key) % size 对应唯一下标，则 get 时间复杂度是 O(1) 。 2、k 个 key 经过 hash(key) % size 对应唯一下标，那么在 get 这 k 个 key 的时间复杂度是 O(k) 。 3、在情况 2 的极端情况下，k 恰好等于 N ，那么是不是就出现我们在上面说的 O(N) 的时间复杂度的情况。 为了解决最差 O(N) 的时间复杂度的情况，可以将数组的每个元素对应成其它数据结构，例如说：1）==红黑树==；2）==跳表==。它们两者的时间复杂度是 O(logN)，这样 O(N) 就可以缓解成 O(logN) 的时间复杂度。 在 JDK7 的版本中，HashMap 采用“数组 + 链表”的形式实现。 在 JDK8 开始的版本，HashMap 采用“数组 + 链表 + 红黑树”的形式实现，在空间和时间复杂度中做取舍。 这一点和 Redis 是相似的，即使是一个数据结构，可能内部采用多种数据结构，混合实现，为了平衡空间和时间复杂度。毕竟，时间不是唯一的因素，我们还需要考虑内存的情况。 如此，HashMap 的整体结构如下图： 扩容 我们是希望 HashMap 尽可能能够达到 O(1) 的时间复杂度，链表法只是我们解决哈希冲突的无奈之举。而在 O(1) 的时间复杂度，基本是“一个萝卜一个坑”，所以在 HashMap 的 key-value 键值对数量达到阀值后，就会进行扩容。 那么阀值是什么，又是怎么计算呢？此时就引入负载因子的概念。我们假设 HashMap 的数组容量为 capacity ，key-value 键值对数量为 size ，负载因子为 loadFactor 。那么，当 capacity / size &gt; loadFactor 时，也就是使用的数组大小到达 loadFactor 比例时，我们就需要进行扩容。如此，我们便可以尽量达到“一个萝卜一个坑”的目的，从而尽可能的 O(1) 的时间复杂度。 下面，我们来看看 HashMap 的属性。代码如下： 123456789101112131415161718192021222324252627282930313233// HashMap.java/* ---------------- Fields -------------- *//** * 底层存储的数组 */transient Node&lt;K,V&gt;[] table;/** * 调用 `#entrySet()` 方法后的缓存 */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * key-value 的键值对数量 */transient int size;/** * HashMap 的修改次数 */transient int modCount;/** * 阀值，当 &#123;@link #size&#125; 超过 &#123;@link #threshold&#125; 时，会进行扩容 */int threshold;/** * 扩容因子 */final float loadFactor; table Node 数组。代码如下： 123456789101112131415161718192021222324// HashMap.java#Node.javastatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; /** * 哈希值 */ final int hash; /** * KEY 键 */ final K key; /** * VALUE 值 */ V value; /** * 下一个节点 */ Node&lt;K,V&gt; next; // ... 省略实现方法&#125; 实现了 Map.Entry 接口，该接口定义在 java.util.Map 接口中。 hash + key + value 属性，定义了 Node 节点的 3 个重要属性。 next 属性，指向下一个节点。通过它可以实现 table 数组的每一个位置可以形成链表。 Node 子类如下图： TreeNode ，定义在 HashMap 中，红黑树节点。通过它可以实现 table 数组的每一个位置可以形成红黑树。 4. 构造方法"}]